

<!DOCTYPE html>
<html class="writer-html5" lang="Python" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NMTF &mdash; SCOTCH &#39;1.1.0&#39; documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=0398fb1d"></script>
      <script src="../_static/doctools.js?v=9a2dae69"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            SCOTCH
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">pyNMTF</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../run_sim_example.html">Running SCOTCH on Simulated Data</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">SCOTCH</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../utilities.html">Utility Functions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">SCOTCH</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">NMTF</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for NMTF</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.gridspec</span> <span class="k">as</span> <span class="nn">GridSpec</span>
<span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">ListedColormap</span>
<span class="kn">import</span> <span class="nn">imageio.v2</span> <span class="k">as</span> <span class="nn">imageio</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.sm_exceptions</span> <span class="kn">import</span> <span class="n">ValueWarning</span>

<span class="kn">import</span> <span class="nn">initialize</span>
<span class="kn">from</span> <span class="nn">torchmetrics.classification</span> <span class="kn">import</span> <span class="n">MulticlassJaccardIndex</span>

<span class="kn">import</span> <span class="nn">scipy.cluster.hierarchy</span> <span class="k">as</span> <span class="nn">sch</span>


<div class="viewcode-block" id="NMTF">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF">[docs]</a>
<span class="k">class</span> <span class="nc">NMTF</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for NMTF model. Provides minimal support functionality and returns factorized matrices.</span>

<span class="sd">    :param k1: Number of components for U matrix. (Default: 2)</span>
<span class="sd">    :type k1: int</span>

<span class="sd">    :param k2: Number of components for V matrix. (Default: 2)</span>
<span class="sd">    :type k2: int</span>

<span class="sd">    :param verbose: If True, displays progress messages. (Default: True)</span>
<span class="sd">    :type verbose: bool, optional</span>

<span class="sd">    :param max_iter: Maximum number of iterations for optimization. (Default: 100)</span>
<span class="sd">    :type max_iter: int, optional</span>

<span class="sd">    :param seed: Seed for random number generation. (Default: 1001)</span>
<span class="sd">    :type seed: int, optional</span>

<span class="sd">    :param term_tol: Tolerance level for convergence, defined by relative change of error. (Default: 1e-5)</span>
<span class="sd">    :type term_tol: float, optional</span>

<span class="sd">    :param max_l_u: Maximum orthogonal regularization term for U matrix. (Default: 0)</span>
<span class="sd">    :type max_l_u: float, optional</span>

<span class="sd">    :param max_l_v: Maximum orthogonal regularization term for V matrix. (Default: 0)</span>
<span class="sd">    :type max_l_v: float, optional</span>

<span class="sd">    :param max_a_u: Maximum sparsity constraint for U matrix. (Default: 0)</span>
<span class="sd">    :type max_a_u: float, optional</span>

<span class="sd">    :param max_a_v: Maximum sparsity constraint for V matrix. (Default: 0)</span>
<span class="sd">    :type max_a_v: float, optional</span>

<span class="sd">    :param var_lambda: If True, lambda increases based on a sigmoid schedule. (Default: False)</span>
<span class="sd">    :type var_lambda: bool, optional</span>

<span class="sd">    :param var_alpha: If True, alpha increases based on a sigmoid schedule. (Default: False)</span>
<span class="sd">    :type var_alpha: bool, optional</span>

<span class="sd">    :param shape_param: Controls the steepness of the sigmoid schedule for both alpha and lambda. (Default: 10)</span>
<span class="sd">    :type shape_param: float, optional</span>

<span class="sd">    :param mid_epoch_param: Epoch at which the sigmoid scheduling function achieves a mean value. (Default: 5)</span>
<span class="sd">    :type mid_epoch_param: int, optional</span>

<span class="sd">    :param init_style: Initialization method for factors; either &quot;nnsvd&quot; (default) or &quot;random&quot;.</span>
<span class="sd">    :type init_style: str, optional</span>

<span class="sd">    :param save_clust: If True, saves cluster assignments after every iteration. (Default: False)</span>
<span class="sd">    :type save_clust: bool, optional</span>

<span class="sd">    :param track_objective: If True, tracks the objective function. (Default: False)</span>
<span class="sd">    :type track_objective: bool, optional</span>

<span class="sd">    :param kill_factors: If True, halts updates if factor values go to zero. (Default: False)</span>
<span class="sd">    :type kill_factors: bool, optional</span>

<span class="sd">    :param device: Device for computation, either &quot;cpu&quot; or &quot;cuda&quot;. (Default: &quot;cpu&quot;)</span>
<span class="sd">    :type device: str, optional</span>

<span class="sd">    :param out_path: Path to save output files. (Default: &#39;.&#39;)</span>
<span class="sd">    :type out_path: str, optional</span>

<span class="sd">    :rtype: NMTF object</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> <span class="n">term_tol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>
                 <span class="n">max_l_u</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_l_v</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_a_u</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_a_v</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">k1</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">k2</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="n">var_lambda</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">var_alpha</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">shape_param</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">mid_epoch_param</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                 <span class="n">init_style</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span> <span class="n">save_clust</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">draw_intermediate_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save_intermediate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">track_objective</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">kill_factors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">out_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">legacy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="c1"># Initialize Parameter space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_iter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">termTol</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">term_tol</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_lU</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_l_u</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_lV</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_l_v</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_aU</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_a_u</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_aV</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_a_v</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aV</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_lambda</span> <span class="o">=</span> <span class="n">var_lambda</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_alpha</span> <span class="o">=</span> <span class="n">var_alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_param</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">shape_param</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mid_epoch_param</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mid_epoch_param</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_style</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">init_style</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_clust</span> <span class="o">=</span> <span class="n">save_clust</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kill_factors</span> <span class="o">=</span> <span class="n">kill_factors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">track_objective</span> <span class="o">=</span> <span class="n">track_objective</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_intermediate</span> <span class="o">=</span> <span class="n">save_intermediate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_intermediate_graph</span> <span class="o">=</span> <span class="n">draw_intermediate_graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frames</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_intermediate_graph</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">out_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">out_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_path</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># self.error = torch.empty(0)</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># Initialize Matrices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_u</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_v</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">legacy</span> <span class="o">=</span> <span class="n">legacy</span>

        <span class="c1"># Initialize matrices for saving cluster assignments throughout training</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_JI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_JI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Initialize matrices for tracking objective function parts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lU_error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lV_error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="NMTF.assign_X_data">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.assign_X_data">[docs]</a>
    <span class="k">def</span> <span class="nf">assign_X_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a Torch data object to SCOTCH. The input `X` must be a two-dimensional, non-negative Torch tensor.</span>

<span class="sd">        :param X: Torch data object to add to SCOTCH. Must be a two-dimensional, non-negative Torch tensor.</span>
<span class="sd">        :type X: torch.Tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;X must be torch tensor object&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;X must be a two dimensional tensor&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">X</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;X must be non-negative&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_u</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_v</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span> <span class="o">=</span> <span class="kc">True</span></div>


    <span class="k">def</span> <span class="nf">_initialize_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the parameters U, V, S, P, Q, and R based on the specified initialization style.</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_style</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_v</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_style</span> <span class="o">==</span> <span class="s2">&quot;nnsvd&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">initialize</span><span class="o">.</span><span class="n">nnsvd_nmtf_initialize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">send_to_gpu</span><span class="p">()</span>

            <span class="c1"># Not a real good way of doing this. Start with something random and let&#39;s update S first.</span>
            <span class="c1"># Perhaps bias toward diagonal.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not a valid initialization method.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">999</span>

        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="NMTF.send_to_gpu">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.send_to_gpu">[docs]</a>
    <span class="k">def</span> <span class="nf">send_to_gpu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sends all tensors to GPU if CUDA is available.</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="c1"># self.error.to(self.device)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="NMTF.send_to_cpu">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.send_to_cpu">[docs]</a>
    <span class="k">def</span> <span class="nf">send_to_cpu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sends all tensors to the CPU if CUDA is available.</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="c1"># self.error.to(self.device)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


    <span class="c1"># Update rules</span>
    <span class="k">def</span> <span class="nf">_update_kth_block_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the kth factor of the U matrix.</span>

<span class="sd">        :param k: Index of the block to update.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">q_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="n">q_norm</span>

        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_update_kth_block_u_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Updates the kth factor of the U matrix and normalizes this vector.</span>

<span class="sd">                :param k: Index of the block to update.</span>
<span class="sd">                :type k: int</span>

<span class="sd">                :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span>

        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Normalize to unit length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:])</span>

    <span class="k">def</span> <span class="nf">_apply_orthog_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the orthogonal regularization term to the kth factor of the U matrix.</span>

<span class="sd">        :param k: Index of the block to update.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">q_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c1"># Orthogonality term</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">k</span><span class="p">]]],</span>
                                                              <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">q_norm</span>
        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_apply_orthog_u_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">               Applies the orthogonal regularization term to the kth factor of the U matrix. Assumes unit norm and uses lambda* for regularization.</span>

<span class="sd">               :param k: Index of the block to update.</span>
<span class="sd">               :type k: int</span>

<span class="sd">               :returns: None</span>
<span class="sd">               &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">k</span><span class="p">]]],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="c1"># apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_apply_sparsity_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the sparsity regularization term to the kth factor of the U matrix.</span>

<span class="sd">        :param k: Index of the kth factor.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">q_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c1"># Sparsity term</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_u</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">/</span> <span class="n">q_norm</span>

        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_apply_sparsity_u_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the sparsity regularization term to the kth factor of the U matrix. Assumes unit norm of U.</span>

<span class="sd">        :param k: Index of the kth factor.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_u</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_enforce_non_zero_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enforces non-zero values in column k of self.U. If the sum of the column is zero, it sets all values to 1/num_u.</span>
<span class="sd">        If citer is greater than 5 and kill_factors is True, the program exits with an error message.</span>

<span class="sd">        :param k: Index of a column in self.U to enforce non-zero values.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Enforce non-zero</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">torch</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_u</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">kill_factors</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Cell factor killed&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_update_kth_block_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the kth block of the V matrix.</span>

<span class="sd">        :param k: Index of the row of V to update.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">p_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[:,</span> <span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="o">/</span> <span class="n">p_norm</span>

        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_update_kth_block_v_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Updates the kth block of the V matrix and normalizes the vector to unit length.</span>

<span class="sd">                :param k: Index of the row of V to update.</span>
<span class="sd">                :type k: int</span>

<span class="sd">                :returns: None</span>
<span class="sd">                &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[:,</span> <span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Normalize V</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_apply_orthog_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the orthogonal regularization update to the kth factor of V.</span>

<span class="sd">        :param k: Index of the column to apply regularization.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">p_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c1"># Orthogonality term</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">k</span><span class="p">]],</span> <span class="p">:],</span>
                                                              <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">p_norm</span>

        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_apply_orthog_v_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the orthogonal regularization update to the kth factor of V using the lambda* interpretation.</span>

<span class="sd">        :param k: Index of the column to apply regularization.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">k</span><span class="p">]],</span> <span class="p">:],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Normalize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_apply_sparsity_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the sparsity regularization update to the kth factor of V.</span>

<span class="sd">        :param k: Index of the column to apply sparsity.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">p_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c1"># Sparsity term</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">aV</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_v</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">/</span> <span class="n">p_norm</span>

        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_apply_sparsity_v_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the sparsity update to the kth factor of V using the lambda* interpretation.</span>

<span class="sd">        :param k: Index of the column to apply sparsity.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">aV</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_v</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Normalize V</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_enforce_non_zero_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enforces a non-zero value for the gene factor at index k. If the sum of values of the gene factor row is zero,</span>
<span class="sd">        it assigns equal weights to each value.</span>

<span class="sd">        :param k: Index of the gene.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>

<span class="sd">        If the condition self.citer &gt; 5 and self.kill_factors is True, the program exits with the message</span>
<span class="sd">        &quot;Gene factor killed&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Enforce non-zero</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">torch</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_v</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">kill_factors</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Gene factor killed&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_update_ith_jth_of_s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates each cell (i, j) of the S (sharing) matrix.</span>

<span class="sd">        :param i: Row index of the S matrix to update.</span>
<span class="sd">        :type i: int</span>

<span class="sd">        :param j: Column index of the S matrix to update.</span>
<span class="sd">        :type j: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">u_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">v_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="n">u_norm</span> <span class="o">*</span> <span class="n">v_norm</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Update the residuals</span>
    <span class="k">def</span> <span class="nf">_update_P</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the P matrix (U * S). The P matrix must be updated before refining V.</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_update_Q</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Updates the Q matrix (S * V). The Q matrix must be updated before refining U.</span>

<span class="sd">                :returns: None</span>
<span class="sd">                &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Scaling functions</span>
    <span class="k">def</span> <span class="nf">_normalize_and_scale_u</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalizes U matrix factors to 1. The scale factor is shifted to the S matrix (i, j) terms.</span>
<span class="sd">        This step is required before applying orthogonal regularization.</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">):</span>
            <span class="n">u_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">/</span> <span class="n">u_norm</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">u_norm</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_normalize_and_scale_v</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalizes V matrix factors to 1. The scale factor is shifted to the S matrix (i, j) terms.</span>
<span class="sd">        This step is required before applying orthogonal regularization.</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">):</span>
            <span class="n">v_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">v_norm</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">v_norm</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Update objectives</span>
    <span class="k">def</span> <span class="nf">_calculate_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Computes the objective function value based on the current state. Adds regularization parameter terms as necessary.</span>

<span class="sd">                :returns: None</span>
<span class="sd">                &quot;&quot;&quot;</span>
        <span class="c1"># Compute reconstruction error</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">error</span>

        <span class="c1"># Compute lU component</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">)</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">diag_embed</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">overlap</span><span class="p">))</span>
            <span class="n">lU_reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">overlap</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lU_reg</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lU_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">lU_reg</span>

        <span class="c1"># Compute lV component</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">@</span> <span class="n">torch</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">diag_embed</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">overlap</span><span class="p">))</span>
            <span class="n">lV_reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">overlap</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lV_reg</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lV_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">lV_reg</span>
        <span class="c1"># Compute aU component</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">aU_reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aU_reg</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Compute aV component</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">aV_reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aV</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aV_reg</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Compute error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">error</span> <span class="o">+</span> <span class="n">lU_reg</span> <span class="o">+</span> <span class="n">lV_reg</span> <span class="o">+</span> <span class="n">aU_reg</span> <span class="o">+</span> <span class="n">aV_reg</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cur_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span>
            <span class="n">prev_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">prev_error</span> <span class="o">-</span> <span class="n">cur_error</span><span class="p">)</span> <span class="o">/</span> <span class="n">prev_error</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_calculate_error_only</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes error term corresponding the frobenius norm term of the objective. This measures the inaccuracy of the</span>
<span class="sd">        reconstruction of X, given the product U, S, V^T</span>

<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Compute reconstruction error</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span> <span class="bp">self</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_update_U</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Update the U matrix.</span>

<span class="sd">                This method iterates through k1 number of columns and performs the following operations:</span>
<span class="sd">                1. Updates the R matrix by adding the outer product of U[:, idx_i] and Q[idx_i, :]</span>
<span class="sd">                2. Calls the &#39;_update_kth_block_u&#39; method to update the kth block of U</span>
<span class="sd">                3. Updates the R matrix by subtracting the outer product of U[:, idx_i] and Q[idx_i, :]</span>

<span class="sd">                After iterating through all columns, it performs the following operations on each column:</span>
<span class="sd">                1. Applies orthogonal regularization if lU &gt; 0 by calling &#39;_apply_orthog_u&#39;</span>
<span class="sd">                2. Applies sparsity control if aU &gt; 0 by calling &#39;_apply_sparsity_u&#39;</span>
<span class="sd">                3. Enforces non-zero elements in the column by calling &#39;_enforce_non_zero_u&#39;</span>

<span class="sd">                :return: None</span>
<span class="sd">                &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">idx_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">idx_i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="p">:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_kth_block_u</span><span class="p">(</span><span class="n">idx_i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">idx_i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="p">:])</span>

        <span class="k">for</span> <span class="n">idx_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_apply_orthog_u</span><span class="p">(</span><span class="n">idx_i</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_apply_sparsity_u</span><span class="p">(</span><span class="n">idx_i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_enforce_non_zero_u</span><span class="p">(</span><span class="n">idx_i</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_update_U_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">               Updates U matrix by iterating over k1 range and performing several operations on it:</span>
<span class="sd">               1. Updates R matrix by adding the outer product of the selected U column and Q row.</span>
<span class="sd">               2. Calls _update_kth_block_u_unit method for further updates.</span>
<span class="sd">               3. Calls _apply_orthog_u_unit method to apply orthogonal constraint.</span>
<span class="sd">               4. Calls _apply_sparsity_u_unit method to enforce sparsity constraint.</span>
<span class="sd">               5. Calls _enforce_non_zero_u method to ensure non-zero values in U matrix.</span>
<span class="sd">               6. Finally, updates R matrix by subtracting the outer product of the selected U column and Q row.</span>

<span class="sd">               :return: None</span>
<span class="sd">               &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">idx_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">idx_i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="p">:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_kth_block_u_unit</span><span class="p">(</span><span class="n">idx_i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_apply_orthog_u_unit</span><span class="p">(</span><span class="n">idx_i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_apply_sparsity_u_unit</span><span class="p">(</span><span class="n">idx_i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_enforce_non_zero_u</span><span class="p">(</span><span class="n">idx_i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">idx_i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_update_V</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Update the V matrix.</span>

<span class="sd">                This method iterates through k2 number of rows and performs the following operations:</span>
<span class="sd">                1. Updates the R matrix by adding the outer product of P[:, idx_j] and V[idx_j, :]</span>
<span class="sd">                2. Calls the &#39;_update_kth_block_v&#39; method to update the kth block of V</span>
<span class="sd">                3. Updates the R matrix by subtracting the outer product of P[:, idx_j] and V[idx_j, :]</span>

<span class="sd">                After iterating through all rows, it performs the following operations on each row:</span>
<span class="sd">                1. Applies orthog reg if lV &gt; 0 by calling &#39;_apply_orthog_v&#39;</span>
<span class="sd">                2. Applies sparsity control if aV &gt; 0 by calling &#39;_apply_sparsity_v&#39;</span>
<span class="sd">                3. Enforces non-zero elements in the row by calling &#39;_enforce_non_zero_v&#39;</span>

<span class="sd">                Returns:</span>
<span class="sd">                    None</span>
<span class="sd">                &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">idx_j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[:,</span> <span class="n">idx_j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idx_j</span><span class="p">,</span> <span class="p">:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_kth_block_v</span><span class="p">(</span><span class="n">idx_j</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[:,</span> <span class="n">idx_j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idx_j</span><span class="p">,</span> <span class="p">:])</span>

        <span class="k">for</span> <span class="n">idx_j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_apply_orthog_v</span><span class="p">(</span><span class="n">idx_j</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_apply_sparsity_v</span><span class="p">(</span><span class="n">idx_j</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_enforce_non_zero_v</span><span class="p">(</span><span class="n">idx_j</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_update_V_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Updates the V matrix by iterating over k2 range and performing several operations on it:</span>
<span class="sd">                1. Updates the R matrix by adding the outer product of P[:, idx_j] and V[idx_j, :].</span>
<span class="sd">                2. Calls the &#39;_update_kth_block_v_unit&#39; method for further updates.</span>
<span class="sd">                3. Calls the &#39;_apply_orthog_v_unit&#39; method to apply orthogonal constraint.</span>
<span class="sd">                4. Calls the &#39;_apply_sparsity_v_unit&#39; method to enforce sparsity constraint.</span>
<span class="sd">                5. Calls the &#39;_enforce_non_zero_v&#39; method to ensure non-zero values in V matrix.</span>
<span class="sd">                6. Finally, updates the R matrix by subtracting the outer product of P[:, idx_j] and V[idx_j, :].</span>

<span class="sd">                Returns:</span>
<span class="sd">                    None</span>
<span class="sd">                &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">idx_j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[:,</span> <span class="n">idx_j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idx_j</span><span class="p">,</span> <span class="p">:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_kth_block_v_unit</span><span class="p">(</span><span class="n">idx_j</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_apply_orthog_v_unit</span><span class="p">(</span><span class="n">idx_j</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_apply_sparsity_v_unit</span><span class="p">(</span><span class="n">idx_j</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_enforce_non_zero_v</span><span class="p">(</span><span class="n">idx_j</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[:,</span> <span class="n">idx_j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idx_j</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_updateS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the matrix R based on the values in matrix S and the matrices U and V.</span>

<span class="sd">        This method performs the following operations:</span>
<span class="sd">        1. Computes the updated value of matrix R by calculating the product of matrices U, S, and V.</span>
<span class="sd">        2. Adjusts the matrix R according to the current state of S, U, and V.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">idx_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">idx_j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="n">idx_j</span><span class="p">]</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">idx_i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idx_j</span><span class="p">,</span> <span class="p">:])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_ith_jth_of_s</span><span class="p">(</span><span class="n">idx_i</span><span class="p">,</span> <span class="n">idx_j</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="n">idx_j</span><span class="p">]</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">idx_i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idx_j</span><span class="p">,</span> <span class="p">:])</span>
            <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="p">:])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1e-5</span>

        <span class="k">for</span> <span class="n">idx_j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[:,</span> <span class="n">idx_j</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[:,</span> <span class="n">idx_j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-5</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="NMTF.update">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.update">[docs]</a>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Defines one update step for the U, V, and S factors.</span>

<span class="sd">        This method updates the U, V, and S matrices in one iteration by performing the necessary operations for</span>
<span class="sd">        each matrix, including applying regularization, sparsity constraints, and other updates to ensure the</span>
<span class="sd">        factors are optimized. It also updates the residual matrix (R) as part of the optimization process.</span>

<span class="sd">        Steps:</span>
<span class="sd">            1. Updates the U matrix using the &#39;_update_U&#39; method.</span>
<span class="sd">            2. Updates the P matrix.</span>
<span class="sd">            3. If lU or aU is greater than 0, recalculates the residual matrix R.</span>
<span class="sd">            4. Updates the V matrix using the &#39;_update_V&#39; method.</span>
<span class="sd">            5. Updates the Q matrix.</span>
<span class="sd">            6. Recalculates the residual matrix R if necessary.</span>
<span class="sd">            7. Updates the S matrix.</span>
<span class="sd">            8. Normalizes and scales U and V matrices.</span>
<span class="sd">            9. Re-updates the P and Q matrices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_U</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_P</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_V</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_Q</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_updateS</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_and_scale_u</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_and_scale_v</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_P</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_Q</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="NMTF.update_unit">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.update_unit">[docs]</a>
    <span class="k">def</span> <span class="nf">update_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Defines one update step for U, V, and S, using the unit rules.</span>

<span class="sd">        This method updates the U, V, and S matrices in one iteration using the unit-based update rules. The update</span>
<span class="sd">        steps ensure that regularization, sparsity constraints, and other necessary updates are applied in the manner</span>
<span class="sd">        that follows the unit rule approach.</span>

<span class="sd">        Steps:</span>
<span class="sd">            1. Updates the U matrix using the &#39;_update_U_unit&#39; method.</span>
<span class="sd">            2. Updates the P matrix.</span>
<span class="sd">            3. Updates the V matrix using the &#39;_update_V_unit&#39; method.</span>
<span class="sd">            4. Updates the Q matrix.</span>
<span class="sd">            5. Updates the S matrix.</span>
<span class="sd">            6. Re-updates the P and Q matrices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_U_unit</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_P</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_V_unit</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_Q</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_updateS</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_P</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_Q</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">None</span></div>


    <span class="k">def</span> <span class="nf">_determine_reg_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Determines the registration state based on the given parameters such as var_lambda, max_lU, sigmoid_schedule,</span>
<span class="sd">            mid_epoch_param, shape_param, var_alpha, max_aU, max_aV. Updates the values of lU, lV, aU, aV accordingly.</span>

<span class="sd">            Steps:</span>
<span class="sd">            1. Checks the value of `var_lambda` to determine if the regularization parameters lU and lV should be adjusted</span>
<span class="sd">               using the sigmoid schedule function or if they should be set to the maximum values.</span>

<span class="sd">            2. Checks the value of `var_alpha` to determine if the sparsity parameters aU and aV should be adjusted</span>
<span class="sd">               using the sigmoid schedule function or if they should be set to the maximum values.</span>

<span class="sd">            Uses instance variables: var_lambda, max_lU, sigmoid_schedule, mid_epoch_param, shape_param, var_alpha, max_aU, max_aV.</span>

<span class="sd">            Returns:</span>
<span class="sd">                None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_lambda</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_lU</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigmoid_schedule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mid_epoch_param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_param</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_lV</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigmoid_schedule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mid_epoch_param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_param</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_lU</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_lV</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_alpha</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_aU</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigmoid_schedule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mid_epoch_param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_param</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_aV</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigmoid_schedule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mid_epoch_param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_param</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_aU</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_aV</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="NMTF.fit">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.fit">[docs]</a>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Fits the data using the optimization algorithm.</span>

<span class="sd">                This method executes the necessary steps to fit the model to the data using an optimization algorithm. It begins by</span>
<span class="sd">                initializing factors, normalizing, and scaling them, and then updates the S matrix. The NMTF algorithm is then started</span>
<span class="sd">                and iterated upon. It tracks the objective function setup and updates the model&#39;s factors at each iteration.</span>

<span class="sd">                Steps:</span>

<span class="sd">                1. Initializes the factors (U, V, and S).</span>
<span class="sd">                2. Normalizes and scales the U and V factors.</span>
<span class="sd">                3. Updates the S matrix.</span>
<span class="sd">                4. Tracks the objective function setup.</span>
<span class="sd">                5. Begins the NMTF optimization algorithm.</span>
<span class="sd">                6. During each iteration:</span>
<span class="sd">                    - Updates U, V, and S using the specified update method (legacy or unit-based).</span>
<span class="sd">                    - Calculates the objective value.</span>
<span class="sd">                    - Optionally prints detailed information about the iteration, including time, objective value, and reconstruction error.</span>
<span class="sd">                    - Optionally saves intermediate values of U, S, and V.</span>
<span class="sd">                    - Optionally tracks cluster convergence using the Jaccard Index for both U and V assignments.</span>
<span class="sd">                    - Optionally visualizes and saves intermediate graphical representations of the factors.</span>
<span class="sd">                7. Stops when the relative error falls below a specified tolerance (termTol).</span>

<span class="sd">                Returns:</span>
<span class="sd">                    None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">curr_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initializing NMTF factors&quot;</span><span class="p">)</span>
        <span class="c1"># Initialize factors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_factors</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_and_scale_u</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_and_scale_v</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updateS</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_objective_setup</span><span class="p">()</span>

        <span class="n">U_jaccard</span> <span class="o">=</span> <span class="n">MulticlassJaccardIndex</span><span class="p">(</span><span class="n">num_classes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">)</span>
        <span class="n">V_jaccard</span> <span class="o">=</span> <span class="n">MulticlassJaccardIndex</span><span class="p">(</span><span class="n">num_classes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Beginning NMTF&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_clust</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_track_clusters_setup</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_intermediate_graph</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visualize_factors</span><span class="p">()</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw_idle</span><span class="p">()</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">renderer</span><span class="o">.</span><span class="n">buffer_rgba</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_determine_reg_state</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">legacy</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_unit</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_objective</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="n">next_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Iter: </span><span class="si">{0}</span><span class="se">\t</span><span class="s2">Iter Time: </span><span class="si">{1:.3f}</span><span class="se">\t</span><span class="s2">Total Time: </span><span class="si">{2:.3f}</span><span class="se">\t</span><span class="s2">Objective: </span><span class="si">{3:.3e}</span><span class="se">\t</span><span class="s2">Relative Delta Objective: </span><span class="si">{4:.3e}</span><span class="se">\t</span><span class="s2">Reconstruction Error: </span><span class="si">{5:.3e}</span><span class="s2">&quot;</span><span class="o">.</span>
                    <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">,</span> <span class="n">next_time</span> <span class="o">-</span> <span class="n">curr_time</span><span class="p">,</span> <span class="n">next_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span>
                <span class="n">curr_time</span> <span class="o">=</span> <span class="n">next_time</span>

            <span class="c1"># If we want intermediate values in U S and V</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_intermediate</span><span class="p">:</span>
                <span class="n">out_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">out_path</span><span class="si">}</span><span class="s2">/ITER_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">print_USV</span><span class="p">(</span><span class="n">out_path</span><span class="p">)</span>

            <span class="c1"># If we want to know about cluster convergence.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_clust</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">U_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">U_predict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span>
                <span class="n">V_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">V_predict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">U_JI</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_jaccard</span><span class="p">(</span><span class="n">U_target</span><span class="p">,</span> <span class="n">U_predict</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">V_JI</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">V_jaccard</span><span class="p">(</span><span class="n">V_target</span><span class="p">,</span> <span class="n">V_predict</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_intermediate_graph</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visualize_factors</span><span class="p">()</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">renderer</span><span class="o">.</span><span class="n">buffer_rgba</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">termTol</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="NMTF.print_USV">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.print_USV">[docs]</a>
    <span class="k">def</span> <span class="nf">print_USV</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_pre</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">               Write the lower-dimensional matrices (U, V, and S) to tab-delimited text files.</span>

<span class="sd">               This method saves the U, V, and S matrices to text files with names based on the</span>
<span class="sd">               provided prefix. The matrices are saved in tab-delimited format and will be named</span>
<span class="sd">               `file_pre_U.txt`, `file_pre_V.txt`, and `file_pre_S.txt`.</span>

<span class="sd">               Args:</span>
<span class="sd">                   file_pre (str): Prefix to append to the file names.</span>

<span class="sd">               Returns:</span>
<span class="sd">                   None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_pre</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;file_pre must be a string&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">file_pre</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;_&#39;</span><span class="p">:</span>
            <span class="n">file_pre</span> <span class="o">=</span> <span class="n">file_pre</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span>

        <span class="n">U_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">U_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">U_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">U_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">U_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">U_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_path</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">file_pre</span> <span class="o">+</span> <span class="s2">&quot;U.txt&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">V_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">V_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">V_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">V_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_path</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">file_pre</span> <span class="o">+</span> <span class="s2">&quot;V.txt&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">S_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">S_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">S_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">S_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_path</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">file_pre</span> <span class="o">+</span> <span class="s2">&quot;S.txt&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="NMTF.print_output">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.print_output">[docs]</a>
    <span class="k">def</span> <span class="nf">print_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write output files related to the factorization and clustering results.</span>

<span class="sd">        This method writes multiple output files, including the lower-dimensional matrices (U, S, V),</span>
<span class="sd">        terms associated with the objective function (e.g., reconstruction error, lambda regularization terms),</span>
<span class="sd">        and the assignment of U and V at every iteration. It also tracks the stepwise convergence of cluster assignments.</span>

<span class="sd">        The output files include:</span>
<span class="sd">            - `reconstruction_error.txt`: The reconstruction error over iterations.</span>
<span class="sd">            - `lU_error.txt`: The lambda regularization error for U.</span>
<span class="sd">            - `lV_error.txt`: The lambda regularization error for V.</span>
<span class="sd">            - `relative_error.txt`: The relative error over iterations.</span>
<span class="sd">            - `U_assign.txt`: The U assignments at each iteration (if `save_clust` is enabled).</span>
<span class="sd">            - `V_assign.txt`: The V assignments at each iteration (if `save_clust` is enabled).</span>
<span class="sd">            - `V_JI.txt`: The Jaccard Index for V assignments (if `save_clust` is enabled).</span>
<span class="sd">            - `U_JI.txt`: The Jaccard Index for U assignments (if `save_clust` is enabled).</span>

<span class="sd">        :param out_path: The path where the output files will be saved.</span>
<span class="sd">        :type out_path: str</span>

<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">print_USV</span><span class="p">(</span><span class="n">out_path</span><span class="p">)</span>

        <span class="c1"># if self.track_objective:</span>
        <span class="n">reconstruction_error_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_error</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">reconstruction_error_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">reconstruction_error_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">reconstruction_error_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">out_path</span> <span class="o">+</span> <span class="s2">&quot;/reconstruction_error.txt&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">lU_error_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU_error</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">lU_error_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">lU_error_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">lU_error_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">out_path</span> <span class="o">+</span> <span class="s1">&#39;/lU_error.txt&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">lV_error_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lV_error</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">lV_error_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">lV_error_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">lV_error_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">out_path</span> <span class="o">+</span> <span class="s2">&quot;/lV_error.txt&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_clust</span><span class="p">:</span>
            <span class="n">U_test_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="n">U_test_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">U_test_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
            <span class="n">U_test_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">out_path</span> <span class="o">+</span> <span class="s2">&quot;/U_assign.txt&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">V_test_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="n">V_test_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">V_test_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
            <span class="n">V_test_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">out_path</span> <span class="o">+</span> <span class="s2">&quot;/V_assign.txt&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">V_JI_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_JI</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="n">V_JI_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">V_JI_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
            <span class="n">V_JI_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">out_path</span> <span class="o">+</span> <span class="s2">&quot;/V_JI.txt&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">U_JI_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_JI</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="n">U_JI_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">U_JI_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
            <span class="n">U_JI_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">out_path</span> <span class="o">+</span> <span class="s2">&quot;/U_JI.txt&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">relative_error_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">relative_error_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">relative_error_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">relative_error_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">out_path</span> <span class="o">+</span> <span class="s2">&quot;/relative_error.txt&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_track_objective_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize and track the objective values for the algorithm&#39;s error terms across iterations.</span>

<span class="sd">        This method sets up tensors to store the reconstruction error, U regularization error, V regularization error,</span>
<span class="sd">        relative error, and overall error for each iteration of the algorithm. It then calls `calculate_objective`</span>
<span class="sd">        to compute the initial objective values.</span>

<span class="sd">        Attributes:</span>
<span class="sd">            reconstruction_error (torch.Tensor): Stores the reconstruction error at each iteration.</span>
<span class="sd">            lU_error (torch.Tensor): Stores the U regularization error at each iteration.</span>
<span class="sd">            lV_error (torch.Tensor): Stores the V regularization error at each iteration.</span>
<span class="sd">            relative_error (torch.Tensor): Stores the relative error at each iteration.</span>
<span class="sd">            error (torch.Tensor): Stores the overall error at each iteration.</span>

<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lU_error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lV_error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_objective</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_track_clusters_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the necessary tensors for tracking clusters setup including U_assign, V_assign, U_JI, V_JI.</span>
<span class="sd">        Set the initial values for U_JI and V_JI as infinity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_JI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_JI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_JI</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_JI</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="NMTF.save_cluster">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.save_cluster">[docs]</a>
    <span class="k">def</span> <span class="nf">save_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">               Save cluster assignments and errors for each iteration of the algorithm.</span>

<span class="sd">               This method initializes tensors to store the cluster assignments for both U and V matrices</span>
<span class="sd">               at each iteration of the algorithm. It also initializes tensors for the Jaccard Index (JI)</span>
<span class="sd">               for both U and V and tracks the relative error over iterations.</span>

<span class="sd">               Steps:</span>
<span class="sd">               1. Initializes tensors for storing U cluster assignments (`U_assign`) and Jaccard Index (`U_JI`).</span>
<span class="sd">               2. Initializes tensors for storing V cluster assignments (`V_assign`) and Jaccard Index (`V_JI`).</span>
<span class="sd">               3. Initializes tensor to store the relative error over iterations (`relative_error`).</span>


<span class="sd">           Returns:</span>
<span class="sd">               None</span>
<span class="sd">       &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_JI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_JI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>


<div class="viewcode-block" id="NMTF.assign_cluster">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.assign_cluster">[docs]</a>
    <span class="k">def</span> <span class="nf">assign_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign clusters based on the lower-dimensional embedding matrices U and V.</span>

<span class="sd">        This method assigns clusters by taking the `argmax` along the appropriate dimensions of the</span>
<span class="sd">        lower-dimensional embedding matrices `U` and `V`. Specifically, it assigns clusters to each</span>
<span class="sd">        data point based on the maximum value in the corresponding row of `U` (for the U assignments)</span>
<span class="sd">        and the maximum value in the corresponding column of `V` (for the V assignments).</span>

<span class="sd">        The cluster assignments are stored in `U_assign` and `V_assign`.</span>

<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_sigmoid_schedule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mid_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mf">10.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a sigmoid scheduling function for the lambda U and lambda V regularization parameters.</span>

<span class="sd">        This function creates a sigmoid schedule for the regularization parameters `LU` and `LV`, where the values</span>
<span class="sd">        of these parameters achieve half of their maximum value at the `mid_iter` (the midpoint iteration). The</span>
<span class="sd">        steepness of the curve is controlled by the `shape` parameter.</span>

<span class="sd">        :param mid_iter: The midpoint iteration where the schedule reaches half of the maximum value.</span>
<span class="sd">        :type mid_iter: int</span>

<span class="sd">        :param shape: The shape parameter that controls the steepness of the sigmoid curve.</span>
<span class="sd">        :type shape: float</span>

<span class="sd">        :return: The value of the sigmoid schedule at the current iteration.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">shape</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="n">mid_iter</span><span class="p">)))</span>

<div class="viewcode-block" id="NMTF.visualize_factors">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.visualize_factors">[docs]</a>
    <span class="k">def</span> <span class="nf">visualize_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">max_u</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_v</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_x</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function generates a visual representation of the NMTF factors, allowing users to specify</span>
<span class="sd">        the colormap and interpolation method used for image display.</span>
<span class="sd">        :param cmap: The colormap to be used for visualization. Default is &#39;viridis&#39;.</span>
<span class="sd">        :type cmap: str, optional</span>
<span class="sd">        :param interp: The interpolation method to be used for image display. Default is &#39;nearest&#39;.</span>
<span class="sd">        :type interp: str, optional</span>
<span class="sd">        :param max_u: The maximum for color scale. Value between [0, 1] where 1 represents the max value in U.</span>
<span class="sd">        Default is 1.</span>
<span class="sd">        :type max_u: float, optional</span>
<span class="sd">        :param max_v: The maximum for color scale. Value between [0, 1] where 1 represents the max value in V.</span>
<span class="sd">        Default is 1.</span>
<span class="sd">        :type max_v: float, optional</span>
<span class="sd">        :param max_x: The maximum for color scale. Value between [0, 1] where 1 represents the max value in X.</span>
<span class="sd">        Default is 1.</span>
<span class="sd">        :type max_x: float, optional</span>
<span class="sd">        :return: U, S, V  matrix heatmaps with X and product.</span>
<span class="sd">        :rtype: matplotlib.figure.Figure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">grids</span> <span class="o">=</span> <span class="n">GridSpec</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">wspace</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">width_ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">),</span> <span class="n">height_ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">))</span>

        <span class="n">U_viz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">U_viz</span> <span class="o">=</span> <span class="p">(</span><span class="n">U_viz</span> <span class="o">-</span> <span class="n">U_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">U_viz</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">U_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">U_viz</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                  <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_u</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="c1"># ax1.set_title(&quot;U Matrix&quot;)</span>

        <span class="c1"># Visualize S matrix</span>
        <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">t</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="c1"># ax2.set_title(&quot;S Matrix&quot;)</span>

        <span class="c1"># Visualize V matrix</span>
        <span class="n">V_viz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">V_viz</span> <span class="o">=</span> <span class="p">(</span><span class="n">V_viz</span> <span class="o">-</span> <span class="n">V_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">V_viz</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">V_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax3</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">V_viz</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                   <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_v</span><span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="c1"># ax3.set_title(&quot;V Matrix&quot;)</span>

        <span class="c1"># Visualize X matrix</span>
        <span class="n">X_est_viz</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">X_est_viz</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_est_viz</span> <span class="o">-</span> <span class="n">X_est_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="p">(</span><span class="n">X_est_viz</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">X_est_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax4</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">X_est_viz</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                   <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_x</span><span class="p">)</span>
        <span class="c1"># ax4.set_title(&quot;X Matrix&quot;)</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

        <span class="n">X_viz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">X_viz</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_viz</span> <span class="o">-</span> <span class="n">X_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">X_viz</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">X_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax5</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">ax5</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">X_viz</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                   <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_x</span><span class="p">)</span>
        <span class="n">ax5</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="NMTF.visualize_factors_sorted">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.visualize_factors_sorted">[docs]</a>
    <span class="k">def</span> <span class="nf">visualize_factors_sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">max_u</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_v</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_x</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function generates a visual representation of the NMTF factors, allowing users to specify</span>
<span class="sd">            the colormap and interpolation method used for image display.</span>
<span class="sd">            :param cmap: Colormap for the visualization. Default is &#39;viridis&#39;.</span>
<span class="sd">            :type cmap: str, optional</span>
<span class="sd">            :param interp: Interpolation method for image display. Default is &#39;nearest&#39;.</span>
<span class="sd">            :type interp: str, optional</span>
<span class="sd">            :param max_u: The maximum for color scale. Value between [0, 1] where 1 represents the max value in U.</span>
<span class="sd">            Default is 1.</span>
<span class="sd">            :type max_u: float, optional</span>
<span class="sd">            :param max_v: The maximum for color scale. Value between [0, 1] where 1 represents the max value in V.</span>
<span class="sd">            Default is 1.</span>
<span class="sd">            :type max_v: float, optional</span>
<span class="sd">            :param max_x: The maximum for color scale. Value between [0, 1] where 1 represents the max value in X.</span>
<span class="sd">            Default is 1.</span>
<span class="sd">            :type max_x: float, optional</span>
<span class="sd">            :return: U, S, V  matrix heatmaps with X and product.</span>
<span class="sd">            :rtype: matplotlib.figure.Figure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">grids</span> <span class="o">=</span> <span class="n">GridSpec</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">wspace</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">width_ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">),</span> <span class="n">height_ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">))</span>

        <span class="c1"># Generate Sorting for U</span>
        <span class="n">max_U</span><span class="p">,</span> <span class="n">max_U_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sorting_criteria</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">max_U_idx</span><span class="p">,</span> <span class="n">max_U</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sorted_U_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sorting_criteria</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stable</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Generate Sorting for V</span>
        <span class="n">max_V</span><span class="p">,</span> <span class="n">max_V_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sorting_criteria</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">max_V_idx</span><span class="p">,</span> <span class="n">max_V</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sorted_V_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sorting_criteria</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stable</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">U_viz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">sorted_U_indices</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">U_viz</span> <span class="o">=</span> <span class="p">(</span><span class="n">U_viz</span> <span class="o">-</span> <span class="n">U_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">U_viz</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">U_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">U_viz</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                   <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_u</span><span class="p">)</span> <span class="c1"># set color scale</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="c1"># ax1.set_title(&quot;U Matrix&quot;)</span>

        <span class="c1"># Visualize S matrix</span>
        <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">t</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="c1"># ax2.set_title(&quot;S Matrix&quot;)</span>

        <span class="c1"># Visualize V matrix</span>
        <span class="n">V_viz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[:,</span> <span class="n">sorted_V_indices</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">V_viz</span> <span class="o">=</span> <span class="p">(</span><span class="n">V_viz</span> <span class="o">-</span> <span class="n">V_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="p">(</span><span class="n">V_viz</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">V_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax3</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">V_viz</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                   <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_v</span><span class="p">)</span> <span class="c1"># set color scale</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="c1"># ax3.set_title(&quot;V Matrix&quot;)</span>

        <span class="c1"># Visualize X matrix</span>
        <span class="n">X_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span>
        <span class="n">X_est</span> <span class="o">=</span> <span class="n">X_est</span><span class="p">[</span><span class="n">sorted_U_indices</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">X_est</span> <span class="o">=</span> <span class="n">X_est</span><span class="p">[:,</span> <span class="n">sorted_V_indices</span><span class="p">]</span>
        <span class="n">X_est</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_est</span> <span class="o">-</span> <span class="n">X_est</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">X_est</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">X_est</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax4</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">X_est</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                   <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_x</span><span class="p">)</span> <span class="c1"># set color scale</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

        <span class="c1"># ax4.set_title(&quot;X Matrix&quot;)</span>
        <span class="n">X_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">X_temp</span> <span class="o">=</span> <span class="n">X_temp</span><span class="p">[</span><span class="n">sorted_U_indices</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">X_temp</span> <span class="o">=</span> <span class="n">X_temp</span><span class="p">[:,</span> <span class="n">sorted_V_indices</span><span class="p">]</span>
        <span class="n">X_temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_temp</span> <span class="o">-</span> <span class="n">X_temp</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">X_temp</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">X_temp</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax5</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">ax5</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">X_temp</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                   <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_x</span><span class="p">)</span> <span class="c1"># set color scale</span>
        <span class="n">ax5</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="NMTF.write_gif">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.write_gif">[docs]</a>
    <span class="k">def</span> <span class="nf">write_gif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;NMTF_fit.gif&quot;</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save frames of NMTF fit to a GIF figure.</span>

<span class="sd">        This method generates and saves a GIF showing the intermediate steps of the NMTF fitting process.</span>
<span class="sd">        It is important that the `draw_interm ediate_graph` parameter is set to `True` during the fit to</span>
<span class="sd">        capture these frames.</span>

<span class="sd">        :param filename: The file name to save the GIF. Default is &quot;NMTF_fit.gif&quot;.</span>
<span class="sd">        :type filename: str, optional</span>

<span class="sd">        :param fps: The desired frames per second for the GIF. Default is 5.</span>
<span class="sd">        :type fps: int, optional</span>

<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;filename must be a str&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fps</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;fps must be a int&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fps</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fps must be positive integer&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_path</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">filename</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">outfile</span> <span class="o">=</span> <span class="s2">&quot;fit.gif&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;writing gif to </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outfile</span><span class="p">))</span>
        <span class="n">imageio</span><span class="o">.</span><span class="n">mimsave</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="NMTF.recluster_V">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.recluster_V">[docs]</a>
    <span class="k">def</span> <span class="nf">recluster_V</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linkage_type</span><span class="o">=</span><span class="s2">&quot;average&quot;</span><span class="p">,</span> <span class="n">dist_metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clusters the V matrix using hierarchical clustering, with the specified linkage type and distance metric.</span>
<span class="sd">        Afterward, it reapplies SCOTCH based on the cluster representations to remove overly redundant factors from S.</span>

<span class="sd">        This process involves performing hierarchical clustering on the V matrix to group similar factors and</span>
<span class="sd">        reduce redundancy. SCOTCH is then reapplied to the clustered data to improve the factorization.</span>

<span class="sd">        :param linkage_type: The type of linkage method to use for hierarchical clustering.</span>
<span class="sd">            Must be one of the following: &#39;single&#39;, &#39;complete&#39;, &#39;average&#39;, or &#39;ward&#39;.</span>
<span class="sd">            Default is &#39;average&#39;.</span>
<span class="sd">        :type linkage_type: str</span>

<span class="sd">        :param dist_metric: The distance metric used for calculating pairwise distances in clustering.</span>
<span class="sd">            It can be one of the following: &#39;cosine&#39;, &#39;euclidean&#39;, &#39;city_block&#39;, &#39;chebyshev&#39;,</span>
<span class="sd">            or an integer for a p-metric. Default is &#39;euclidean&#39;.</span>
<span class="sd">        :type dist_metric: str or int</span>

<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use a pseudo-Q representation to recluster.</span>
        <span class="c1"># This is to make sure we don&#39;t have any additive representations in V</span>
        <span class="c1"># Row normalize</span>

        <span class="k">if</span> <span class="n">dist_metric</span> <span class="o">==</span> <span class="s2">&quot;cosine&quot;</span><span class="p">:</span>
            <span class="n">cosine_sim</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">cosine_similarity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">D</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">cosine_sim</span>
        <span class="k">elif</span> <span class="n">dist_metric</span> <span class="o">==</span> <span class="s2">&quot;euclidean&quot;</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dist_metric</span> <span class="o">==</span> <span class="s2">&quot;city_block&quot;</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dist_metric</span> <span class="o">==</span> <span class="s2">&quot;chebyshev&quot;</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_metric</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">dist_metric</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dist metric is invalid. Value must be one of cosine, euclidean, city_block, chebyshev, or&quot;</span>
                             <span class="s2">&quot;an integer for a p metric&quot;</span><span class="p">)</span>

        <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="c1"># Cluster V by S representation for each gene</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">sch</span><span class="o">.</span><span class="n">linkage</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">linkage_type</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">sch</span><span class="o">.</span><span class="n">fcluster</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="s1">&#39;maxclust&#39;</span><span class="p">)</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Estimate a new S based on the mean S per cluster</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">):</span>
            <span class="n">cluster_indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">clusters</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">as_tuple</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cluster_indices</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[:,</span> <span class="n">cluster_indices</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># refit.</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">curr_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_and_scale_v</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updateS</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_objective_setup</span><span class="p">()</span>
        <span class="n">U_jaccard</span> <span class="o">=</span> <span class="n">MulticlassJaccardIndex</span><span class="p">(</span><span class="n">num_classes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">)</span>
        <span class="n">V_jaccard</span> <span class="o">=</span> <span class="n">MulticlassJaccardIndex</span><span class="p">(</span><span class="n">num_classes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_clust</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_track_clusters_setup</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_intermediate_graph</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visualize_factors</span><span class="p">()</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">renderer</span><span class="o">.</span><span class="n">buffer_rgba</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_determine_reg_state</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">legacy</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_unit</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_objective</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="n">next_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Iter: </span><span class="si">{0}</span><span class="se">\t</span><span class="s2">Iter Time: </span><span class="si">{1:.3f}</span><span class="se">\t</span><span class="s2">Total Time: </span><span class="si">{2:.3f}</span><span class="se">\t</span><span class="s2">Objective: </span><span class="si">{3:.3e}</span><span class="se">\t</span><span class="s2">Relative Delta Objective: </span><span class="si">{4:.3e}</span><span class="se">\t</span><span class="s2">Reconstruction Error: </span><span class="si">{5:.3e}</span><span class="s2">&quot;</span><span class="o">.</span>
                    <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">,</span> <span class="n">next_time</span> <span class="o">-</span> <span class="n">curr_time</span><span class="p">,</span> <span class="n">next_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span>
                <span class="n">curr_time</span> <span class="o">=</span> <span class="n">next_time</span>

            <span class="c1"># If we want intermediate values in U S and V</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_intermediate</span><span class="p">:</span>
                <span class="n">out_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">out_path</span><span class="si">}</span><span class="s2">/ITER_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">print_USV</span><span class="p">(</span><span class="n">out_path</span><span class="p">)</span>

            <span class="c1"># If we want to know about cluster convergence.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_clust</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">U_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">U_predict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span>
                <span class="n">V_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">V_predict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">U_JI</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_jaccard</span><span class="p">(</span><span class="n">U_target</span><span class="p">,</span> <span class="n">U_predict</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">V_JI</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">V_jaccard</span><span class="p">(</span><span class="n">V_target</span><span class="p">,</span> <span class="n">V_predict</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_intermediate_graph</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visualize_factors</span><span class="p">()</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">renderer</span><span class="o">.</span><span class="n">buffer_rgba</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">termTol</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span></div>


<div class="viewcode-block" id="NMTF.visualize_clusters">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.visualize_clusters">[docs]</a>
    <span class="k">def</span> <span class="nf">visualize_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">max_x</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Visualizes the factors from the NMTF model.</span>

<span class="sd">        This function generates a visualization of the factors resulting from the NMTF model. It supports customizing the</span>
<span class="sd">        color scheme, interpolation method, and the scaling of the visualization.</span>

<span class="sd">        :param factor_name: The name of the factor to visualize (e.g., &#39;U&#39;, &#39;V&#39;).</span>
<span class="sd">        :type factor_name: str</span>

<span class="sd">        :param cmap: The colormap to use for the visualization. Default is &#39;viridis&#39;.</span>
<span class="sd">        :type cmap: str, optional</span>

<span class="sd">        :param interp: The interpolation method for rendering. Default is &#39;nearest&#39;.</span>
<span class="sd">        :type interp: str, optional</span>

<span class="sd">        :param max_val: The maximum value for scaling the color map. Default is 1.</span>
<span class="sd">        :type max_val: float, optional</span>

<span class="sd">        :return: The matplotlib figure object representing the factor visualization.</span>
<span class="sd">        :rtype: matplotlib.figure.Figure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">grids</span> <span class="o">=</span> <span class="n">GridSpec</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">hspace</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">wspace</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">width_ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">),</span> <span class="n">height_ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">))</span>

        <span class="c1"># Setup safe color palette for U</span>
        <span class="n">n_u_clusters</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">)</span>
        <span class="n">tab_20</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;tab20&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_u_clusters</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ValueWarning</span><span class="p">(</span><span class="s1">&#39;Number of U clusters exceeds maximum number of supported by palette (tab20). Repeat &#39;</span>
                               <span class="s1">&#39;colors will be used.&#39;</span><span class="p">)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">tab_20</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">20</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_u_clusters</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">u_cmap</span> <span class="o">=</span> <span class="n">ListedColormap</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>

        <span class="c1"># Visualize U matrix</span>
        <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">u_cmap</span><span class="p">,</span>
                   <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

        <span class="n">n_v_clusters</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_v_clusters</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ValueWarning</span><span class="p">(</span><span class="s1">&#39;Number of V clusters exceeds maximum of supported by palette (tab20). Repeat &#39;</span>
                               <span class="s2">&quot;colors will be used.&quot;</span><span class="p">)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">tab_20</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">20</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_v_clusters</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">v_cmap</span> <span class="o">=</span> <span class="n">ListedColormap</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>

        <span class="c1"># Visualize V matrix</span>
        <span class="n">ax3</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">v_cmap</span><span class="p">,</span>
                   <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

        <span class="n">ax4</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">X_viz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">X_viz</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_viz</span> <span class="o">-</span> <span class="n">X_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">X_viz</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">X_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">X_viz</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                   <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_x</span><span class="p">)</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="NMTF.visualize_clusters_sorted">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.visualize_clusters_sorted">[docs]</a>
    <span class="k">def</span> <span class="nf">visualize_clusters_sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">max_x</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Visualizes the clusters by ordering elements of the matrix based on their cluster assignments.</span>

<span class="sd">            The function sorts the elements of the matrix by their cluster order and alternates the color of each</span>
<span class="sd">                cluster between grey and black. This approach avoids potential issues with limited color palettes, ensuring</span>
<span class="sd">                better visual distinction between clusters.</span>

<span class="sd">            :param cmap: The colormap to be used for visualization. Defaults to &#39;viridis&#39;.</span>
<span class="sd">            :type cmap: str, optional</span>
<span class="sd">            :param interp: The interpolation method for rendering the image. Defaults to &#39;nearest&#39;.</span>
<span class="sd">            :type interp: str, optional</span>
<span class="sd">            :param max_x: The maximum for color scale. Value between [0, 1] where 1 represents the max value in X.</span>
<span class="sd">                Default is 1.</span>
<span class="sd">            :type max_x: int, optional</span>
<span class="sd">            :return: Sorted clusters heatmap representation.</span>
<span class="sd">            :rtype: matplotlib.figure.Figure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">grids</span> <span class="o">=</span> <span class="n">GridSpec</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">hspace</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">wspace</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">width_ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">),</span> <span class="n">height_ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">))</span>

        <span class="c1"># Generate Sorting for U</span>
        <span class="n">max_U</span><span class="p">,</span> <span class="n">max_U_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sorting_criteria</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">max_U_idx</span><span class="p">,</span> <span class="n">max_U</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sorted_U_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sorting_criteria</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stable</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Generate Sorting for V</span>
        <span class="n">max_V</span><span class="p">,</span> <span class="n">max_V_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sorting_criteria</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">max_V_idx</span><span class="p">,</span> <span class="n">max_V</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sorted_V_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sorting_criteria</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stable</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">barcode_U</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">class_value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">)):</span>
            <span class="n">barcode_U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span> <span class="o">==</span> <span class="n">class_value</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">1.0</span>

        <span class="n">barcode_V</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">class_value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">)):</span>
            <span class="n">barcode_V</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span> <span class="o">==</span> <span class="n">class_value</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">1.0</span>

        <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">barcode_U</span><span class="p">[</span><span class="n">sorted_U_indices</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                   <span class="n">vmax</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

        <span class="c1"># Visualize V matrix</span>
        <span class="n">ax3</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">barcode_V</span><span class="p">[</span><span class="n">sorted_V_indices</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span>
                   <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="c1"># ax3.set_title(&quot;V Matrix&quot;)</span>

        <span class="n">X_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()[</span><span class="n">sorted_U_indices</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">sorted_V_indices</span><span class="p">]</span>
        <span class="n">X_temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_temp</span> <span class="o">-</span> <span class="n">X_temp</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">X_temp</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">X_temp</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax5</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ax5</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">X_temp</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                   <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_x</span><span class="p">)</span>
        <span class="n">ax5</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>
</div>




</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Spencer Halberg-Spencer, Harmon Bhasin, Sushmita Roy.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>