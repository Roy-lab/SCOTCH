<!DOCTYPE html>

<html lang="Python" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel="stylesheet">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#3f51b5">
  <script src="../_static/javascripts/modernizr.js"></script>
  
  
  
    <title>NMTF &#8212; SCOTCH &#39;1.1.0&#39; documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=e7352e39" />
    <link rel="stylesheet" type="text/css" href="../_static/material.css?v=79c92029" />
    <script src="../_static/documentation_options.js?v=0398fb1d"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
  
   

  </head>
  <body dir=ltr
        data-md-color-primary=blue-grey data-md-color-accent=blue>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#_modules/NMTF" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../index.html" title="SCOTCH &#39;1.1.0&#39; documentation"
           class="md-header-nav__button md-logo">
          
            &nbsp;
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">SCOTCH '1.1.0' documentation</span>
          <span class="md-header-nav__topic"> NMTF </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../search.html" method="get" name="search">
      <input type="text" class="md-search__input" name="q" placeholder=""Search""
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
      
  
  <script src="../_static/javascripts/version_dropdown.js"></script>
  <script>
    var json_loc = "../"versions.json"",
        target_loc = "../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
  </script>
  

    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
          <li class="md-tabs__item"><a href="../index.html" class="md-tabs__link">SCOTCH '1.1.0' documentation</a></li>
          <li class="md-tabs__item"><a href="index.html" class="md-tabs__link">Module code</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../index.html" title="SCOTCH &#39;1.1.0&#39; documentation" class="md-nav__button md-logo">
      
        <img src="../_static/" alt=" logo" width="48" height="48">
      
    </a>
    <a href="../index.html"
       title="SCOTCH &#39;1.1.0&#39; documentation">SCOTCH '1.1.0' documentation</a>
  </label>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
  <ul class="md-nav__list" data-md-scrollfix="">
    

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  <h1 id="modules-nmtf--page-root">Source code for NMTF</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.gridspec</span> <span class="k">as</span> <span class="nn">GridSpec</span>
<span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">ListedColormap</span>
<span class="kn">import</span> <span class="nn">imageio.v2</span> <span class="k">as</span> <span class="nn">imageio</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.sm_exceptions</span> <span class="kn">import</span> <span class="n">ValueWarning</span>

<span class="kn">import</span> <span class="nn">initialize</span>
<span class="kn">from</span> <span class="nn">torchmetrics.classification</span> <span class="kn">import</span> <span class="n">MulticlassJaccardIndex</span>

<span class="kn">import</span> <span class="nn">scipy.cluster.hierarchy</span> <span class="k">as</span> <span class="nn">sch</span>


<div class="viewcode-block" id="NMTF">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF">[docs]</a>
<span class="k">class</span> <span class="nc">NMTF</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Base class for NMTF model. Provides minimal support functionality and returns factorized matrices.</span>

<span class="sd">    :param k1: Number of components for U matrix. (Default: 2)</span>
<span class="sd">    :type k1: int</span>

<span class="sd">    :param k2: Number of components for V matrix. (Default: 2)</span>
<span class="sd">    :type k2: int</span>

<span class="sd">    :param verbose: If True, displays progress messages. (Default: True)</span>
<span class="sd">    :type verbose: bool, optional</span>

<span class="sd">    :param max_iter: Maximum number of iterations for optimization. (Default: 100)</span>
<span class="sd">    :type max_iter: int, optional</span>

<span class="sd">    :param seed: Seed for random number generation. (Default: 1001)</span>
<span class="sd">    :type seed: int, optional</span>

<span class="sd">    :param term_tol: Tolerance level for convergence, defined by relative change of error. (Default: 1e-5)</span>
<span class="sd">    :type term_tol: float, optional</span>

<span class="sd">    :param max_l_u: Maximum orthogonal regularization term for U matrix. (Default: 0)</span>
<span class="sd">    :type max_l_u: float, optional</span>

<span class="sd">    :param max_l_v: Maximum orthogonal regularization term for V matrix. (Default: 0)</span>
<span class="sd">    :type max_l_v: float, optional</span>

<span class="sd">    :param max_a_u: Maximum sparsity constraint for U matrix. (Default: 0)</span>
<span class="sd">    :type max_a_u: float, optional</span>

<span class="sd">    :param max_a_v: Maximum sparsity constraint for V matrix. (Default: 0)</span>
<span class="sd">    :type max_a_v: float, optional</span>

<span class="sd">    :param var_lambda: If True, lambda increases based on a sigmoid schedule. (Default: False)</span>
<span class="sd">    :type var_lambda: bool, optional</span>

<span class="sd">    :param var_alpha: If True, alpha increases based on a sigmoid schedule. (Default: False)</span>
<span class="sd">    :type var_alpha: bool, optional</span>

<span class="sd">    :param shape_param: Controls the steepness of the sigmoid schedule for both alpha and lambda. (Default: 10)</span>
<span class="sd">    :type shape_param: float, optional</span>

<span class="sd">    :param mid_epoch_param: Epoch at which the sigmoid scheduling function achieves a mean value. (Default: 5)</span>
<span class="sd">    :type mid_epoch_param: int, optional</span>

<span class="sd">    :param init_style: Initialization method for factors; either "nnsvd" (default) or "random".</span>
<span class="sd">    :type init_style: str, optional</span>

<span class="sd">    :param save_clust: If True, saves cluster assignments after every iteration. (Default: False)</span>
<span class="sd">    :type save_clust: bool, optional</span>

<span class="sd">    :param track_objective: If True, tracks the objective function. (Default: False)</span>
<span class="sd">    :type track_objective: bool, optional</span>

<span class="sd">    :param kill_factors: If True, halts updates if factor values go to zero. (Default: False)</span>
<span class="sd">    :type kill_factors: bool, optional</span>

<span class="sd">    :param device: Device for computation, either "cpu" or "cuda". (Default: "cpu")</span>
<span class="sd">    :type device: str, optional</span>

<span class="sd">    :param out_path: Path to save output files. (Default: '.')</span>
<span class="sd">    :type out_path: str, optional</span>

<span class="sd">    :rtype: NMTF object</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> <span class="n">term_tol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>
                 <span class="n">max_l_u</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_l_v</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_a_u</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_a_v</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">k1</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">k2</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="n">var_lambda</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">var_alpha</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">shape_param</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">mid_epoch_param</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                 <span class="n">init_style</span><span class="o">=</span><span class="s2">"random"</span><span class="p">,</span> <span class="n">save_clust</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">draw_intermediate_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save_intermediate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">track_objective</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">kill_factors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">"cpu"</span><span class="p">,</span> <span class="n">out_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">legacy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="c1"># Initialize Parameter space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_iter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">termTol</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">term_tol</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_lU</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_l_u</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_lV</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_l_v</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_aU</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_a_u</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_aV</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_a_v</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aV</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_lambda</span> <span class="o">=</span> <span class="n">var_lambda</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_alpha</span> <span class="o">=</span> <span class="n">var_alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_param</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">shape_param</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mid_epoch_param</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mid_epoch_param</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_style</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">init_style</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_clust</span> <span class="o">=</span> <span class="n">save_clust</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kill_factors</span> <span class="o">=</span> <span class="n">kill_factors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">track_objective</span> <span class="o">=</span> <span class="n">track_objective</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_intermediate</span> <span class="o">=</span> <span class="n">save_intermediate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_intermediate_graph</span> <span class="o">=</span> <span class="n">draw_intermediate_graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frames</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_intermediate_graph</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">out_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">out_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_path</span> <span class="o">=</span> <span class="s1">'.'</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># self.error = torch.empty(0)</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># Initialize Matrices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_u</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_v</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">legacy</span> <span class="o">=</span> <span class="n">legacy</span>

        <span class="c1"># Initialize matrices for saving cluster assignments throughout training</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_JI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_JI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Initialize matrices for tracking objective function parts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lU_error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lV_error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="NMTF.assign_X_data">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.assign_X_data">[docs]</a>
    <span class="k">def</span> <span class="nf">assign_X_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Adds a Torch data object to SCOTCH. The input `X` must be a two-dimensional, non-negative Torch tensor.</span>

<span class="sd">        :param X: Torch data object to add to SCOTCH. Must be a two-dimensional, non-negative Torch tensor.</span>
<span class="sd">        :type X: torch.Tensor</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'X must be torch tensor object'</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'X must be a two dimensional tensor'</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">X</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'X must be non-negative'</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_u</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_v</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span> <span class="o">=</span> <span class="kc">True</span></div>


    <span class="k">def</span> <span class="nf">_initialize_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Initializes the parameters U, V, S, P, Q, and R based on the specified initialization style.</span>

<span class="sd">        :returns: None</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_style</span> <span class="o">==</span> <span class="s2">"random"</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_v</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_style</span> <span class="o">==</span> <span class="s2">"nnsvd"</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">initialize</span><span class="o">.</span><span class="n">nnsvd_nmtf_initialize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">send_to_gpu</span><span class="p">()</span>

            <span class="c1"># Not a real good way of doing this. Start with something random and let's update S first.</span>
            <span class="c1"># Perhaps bias toward diagonal.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"Not a valid initialization method."</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">999</span>

        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="NMTF.send_to_gpu">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.send_to_gpu">[docs]</a>
    <span class="k">def</span> <span class="nf">send_to_gpu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Sends all tensors to GPU if CUDA is available.</span>

<span class="sd">        :returns: None</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="c1"># self.error.to(self.device)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="NMTF.send_to_cpu">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.send_to_cpu">[docs]</a>
    <span class="k">def</span> <span class="nf">send_to_cpu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Sends all tensors to the CPU if CUDA is available.</span>

<span class="sd">        :returns: None</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="c1"># self.error.to(self.device)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


    <span class="c1"># Update rules</span>
    <span class="k">def</span> <span class="nf">_update_kth_block_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Updates the kth factor of the U matrix.</span>

<span class="sd">        :param k: Index of the block to update.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        """</span>
        <span class="n">q_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="n">q_norm</span>

        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_update_kth_block_u_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">                Updates the kth factor of the U matrix and normalizes this vector.</span>

<span class="sd">                :param k: Index of the block to update.</span>
<span class="sd">                :type k: int</span>

<span class="sd">                :returns: None</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span>

        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Normalize to unit length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:])</span>

    <span class="k">def</span> <span class="nf">_apply_orthog_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Applies the orthogonal regularization term to the kth factor of the U matrix.</span>

<span class="sd">        :param k: Index of the block to update.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        """</span>
        <span class="n">q_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c1"># Orthogonality term</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">k</span><span class="p">]]],</span>
                                                              <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">q_norm</span>
        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_apply_orthog_u_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">               Applies the orthogonal regularization term to the kth factor of the U matrix. Assumes unit norm and uses lambda* for regularization.</span>

<span class="sd">               :param k: Index of the block to update.</span>
<span class="sd">               :type k: int</span>

<span class="sd">               :returns: None</span>
<span class="sd">               """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">k</span><span class="p">]]],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="c1"># apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_apply_sparsity_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Applies the sparsity regularization term to the kth factor of the U matrix.</span>

<span class="sd">        :param k: Index of the kth factor.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        """</span>

        <span class="n">q_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c1"># Sparsity term</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_u</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">/</span> <span class="n">q_norm</span>

        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_apply_sparsity_u_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Applies the sparsity regularization term to the kth factor of the U matrix. Assumes unit norm of U.</span>

<span class="sd">        :param k: Index of the kth factor.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_u</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_enforce_non_zero_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Enforces non-zero values in column k of self.U. If the sum of the column is zero, it sets all values to 1/num_u.</span>
<span class="sd">        If citer is greater than 5 and kill_factors is True, the program exits with an error message.</span>

<span class="sd">        :param k: Index of a column in self.U to enforce non-zero values.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        """</span>

        <span class="c1"># Enforce non-zero</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">torch</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_u</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">kill_factors</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">"Cell factor killed"</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_update_kth_block_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Updates the kth block of the V matrix.</span>

<span class="sd">        :param k: Index of the row of V to update.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        """</span>

        <span class="n">p_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[:,</span> <span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="o">/</span> <span class="n">p_norm</span>

        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_update_kth_block_v_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">                Updates the kth block of the V matrix and normalizes the vector to unit length.</span>

<span class="sd">                :param k: Index of the row of V to update.</span>
<span class="sd">                :type k: int</span>

<span class="sd">                :returns: None</span>
<span class="sd">                """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[:,</span> <span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Normalize V</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_apply_orthog_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Applies the orthogonal regularization update to the kth factor of V.</span>

<span class="sd">        :param k: Index of the column to apply regularization.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        """</span>

        <span class="n">p_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c1"># Orthogonality term</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">k</span><span class="p">]],</span> <span class="p">:],</span>
                                                              <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">p_norm</span>

        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_apply_orthog_v_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Applies the orthogonal regularization update to the kth factor of V using the lambda* interpretation.</span>

<span class="sd">        :param k: Index of the column to apply regularization.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">k</span><span class="p">]],</span> <span class="p">:],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Normalize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_apply_sparsity_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Applies the sparsity regularization update to the kth factor of V.</span>

<span class="sd">        :param k: Index of the column to apply sparsity.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        """</span>

        <span class="n">p_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c1"># Sparsity term</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">aV</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_v</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">/</span> <span class="n">p_norm</span>

        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_apply_sparsity_v_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Applies the sparsity update to the kth factor of V using the lambda* interpretation.</span>

<span class="sd">        :param k: Index of the column to apply sparsity.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">aV</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_v</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Apply Non-negativity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Normalize V</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_enforce_non_zero_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Enforces a non-zero value for the gene factor at index k. If the sum of values of the gene factor row is zero,</span>
<span class="sd">        it assigns equal weights to each value.</span>

<span class="sd">        :param k: Index of the gene.</span>
<span class="sd">        :type k: int</span>

<span class="sd">        :returns: None</span>

<span class="sd">        If the condition self.citer &gt; 5 and self.kill_factors is True, the program exits with the message</span>
<span class="sd">        "Gene factor killed".</span>
<span class="sd">        """</span>
        <span class="c1"># Enforce non-zero</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">torch</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_v</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">kill_factors</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">"Gene factor killed"</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_update_ith_jth_of_s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Updates each cell (i, j) of the S (sharing) matrix.</span>

<span class="sd">        :param i: Row index of the S matrix to update.</span>
<span class="sd">        :type i: int</span>

<span class="sd">        :param j: Column index of the S matrix to update.</span>
<span class="sd">        :type j: int</span>

<span class="sd">        :returns: None</span>
<span class="sd">        """</span>

        <span class="n">u_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">v_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="n">u_norm</span> <span class="o">*</span> <span class="n">v_norm</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Update the residuals</span>
    <span class="k">def</span> <span class="nf">_update_P</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Updates the P matrix (U * S). The P matrix must be updated before refining V.</span>

<span class="sd">        :returns: None</span>
<span class="sd">        """</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_update_Q</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">                Updates the Q matrix (S * V). The Q matrix must be updated before refining U.</span>

<span class="sd">                :returns: None</span>
<span class="sd">                """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Scaling functions</span>
    <span class="k">def</span> <span class="nf">_normalize_and_scale_u</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Normalizes U matrix factors to 1. The scale factor is shifted to the S matrix (i, j) terms.</span>
<span class="sd">        This step is required before applying orthogonal regularization.</span>

<span class="sd">        :returns: None</span>
<span class="sd">        """</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">):</span>
            <span class="n">u_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">/</span> <span class="n">u_norm</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">u_norm</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_normalize_and_scale_v</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Normalizes V matrix factors to 1. The scale factor is shifted to the S matrix (i, j) terms.</span>
<span class="sd">        This step is required before applying orthogonal regularization.</span>

<span class="sd">        :returns: None</span>
<span class="sd">        """</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">):</span>
            <span class="n">v_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">v_norm</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">v_norm</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Update objectives</span>
    <span class="k">def</span> <span class="nf">_calculate_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">                Computes the objective function value based on the current state. Adds regularization parameter terms as necessary.</span>

<span class="sd">                :returns: None</span>
<span class="sd">                """</span>
        <span class="c1"># Compute reconstruction error</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="s1">'fro'</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">error</span>

        <span class="c1"># Compute lU component</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">)</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">diag_embed</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">overlap</span><span class="p">))</span>
            <span class="n">lU_reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">overlap</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lU_reg</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lU_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">lU_reg</span>

        <span class="c1"># Compute lV component</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">@</span> <span class="n">torch</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">diag_embed</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">overlap</span><span class="p">))</span>
            <span class="n">lV_reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">overlap</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lV_reg</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lV_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">lV_reg</span>
        <span class="c1"># Compute aU component</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">aU_reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aU_reg</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Compute aV component</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">aV_reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aV</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aV_reg</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Compute error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">error</span> <span class="o">+</span> <span class="n">lU_reg</span> <span class="o">+</span> <span class="n">lV_reg</span> <span class="o">+</span> <span class="n">aU_reg</span> <span class="o">+</span> <span class="n">aV_reg</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cur_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span>
            <span class="n">prev_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">prev_error</span> <span class="o">-</span> <span class="n">cur_error</span><span class="p">)</span> <span class="o">/</span> <span class="n">prev_error</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">'inf'</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_calculate_error_only</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Computes error term corresponding the frobenius norm term of the objective. This measures the inaccuracy of the</span>
<span class="sd">        reconstruction of X, given the product U, S, V^T</span>

<span class="sd">        :return: None</span>
<span class="sd">        """</span>

        <span class="c1"># Compute reconstruction error</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="s1">'fro'</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span> <span class="bp">self</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_update_U</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">                Update the U matrix.</span>

<span class="sd">                This method iterates through k1 number of columns and performs the following operations:</span>
<span class="sd">                1. Updates the R matrix by adding the outer product of U[:, idx_i] and Q[idx_i, :]</span>
<span class="sd">                2. Calls the '_update_kth_block_u' method to update the kth block of U</span>
<span class="sd">                3. Updates the R matrix by subtracting the outer product of U[:, idx_i] and Q[idx_i, :]</span>

<span class="sd">                After iterating through all columns, it performs the following operations on each column:</span>
<span class="sd">                1. Applies orthogonal regularization if lU &gt; 0 by calling '_apply_orthog_u'</span>
<span class="sd">                2. Applies sparsity control if aU &gt; 0 by calling '_apply_sparsity_u'</span>
<span class="sd">                3. Enforces non-zero elements in the column by calling '_enforce_non_zero_u'</span>

<span class="sd">                :return: None</span>
<span class="sd">                """</span>
        <span class="k">for</span> <span class="n">idx_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">idx_i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="p">:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_kth_block_u</span><span class="p">(</span><span class="n">idx_i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">idx_i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="p">:])</span>

        <span class="k">for</span> <span class="n">idx_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_apply_orthog_u</span><span class="p">(</span><span class="n">idx_i</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_apply_sparsity_u</span><span class="p">(</span><span class="n">idx_i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_enforce_non_zero_u</span><span class="p">(</span><span class="n">idx_i</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_update_U_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">               Updates U matrix by iterating over k1 range and performing several operations on it:</span>
<span class="sd">               1. Updates R matrix by adding the outer product of the selected U column and Q row.</span>
<span class="sd">               2. Calls _update_kth_block_u_unit method for further updates.</span>
<span class="sd">               3. Calls _apply_orthog_u_unit method to apply orthogonal constraint.</span>
<span class="sd">               4. Calls _apply_sparsity_u_unit method to enforce sparsity constraint.</span>
<span class="sd">               5. Calls _enforce_non_zero_u method to ensure non-zero values in U matrix.</span>
<span class="sd">               6. Finally, updates R matrix by subtracting the outer product of the selected U column and Q row.</span>

<span class="sd">               :return: None</span>
<span class="sd">               """</span>
        <span class="k">for</span> <span class="n">idx_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">idx_i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="p">:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_kth_block_u_unit</span><span class="p">(</span><span class="n">idx_i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_apply_orthog_u_unit</span><span class="p">(</span><span class="n">idx_i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_apply_sparsity_u_unit</span><span class="p">(</span><span class="n">idx_i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_enforce_non_zero_u</span><span class="p">(</span><span class="n">idx_i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">idx_i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_update_V</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">                Update the V matrix.</span>

<span class="sd">                This method iterates through k2 number of rows and performs the following operations:</span>
<span class="sd">                1. Updates the R matrix by adding the outer product of P[:, idx_j] and V[idx_j, :]</span>
<span class="sd">                2. Calls the '_update_kth_block_v' method to update the kth block of V</span>
<span class="sd">                3. Updates the R matrix by subtracting the outer product of P[:, idx_j] and V[idx_j, :]</span>

<span class="sd">                After iterating through all rows, it performs the following operations on each row:</span>
<span class="sd">                1. Applies orthog reg if lV &gt; 0 by calling '_apply_orthog_v'</span>
<span class="sd">                2. Applies sparsity control if aV &gt; 0 by calling '_apply_sparsity_v'</span>
<span class="sd">                3. Enforces non-zero elements in the row by calling '_enforce_non_zero_v'</span>

<span class="sd">                Returns:</span>
<span class="sd">                    None</span>
<span class="sd">                """</span>
        <span class="k">for</span> <span class="n">idx_j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[:,</span> <span class="n">idx_j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idx_j</span><span class="p">,</span> <span class="p">:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_kth_block_v</span><span class="p">(</span><span class="n">idx_j</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[:,</span> <span class="n">idx_j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idx_j</span><span class="p">,</span> <span class="p">:])</span>

        <span class="k">for</span> <span class="n">idx_j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_apply_orthog_v</span><span class="p">(</span><span class="n">idx_j</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_apply_sparsity_v</span><span class="p">(</span><span class="n">idx_j</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_enforce_non_zero_v</span><span class="p">(</span><span class="n">idx_j</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_update_V_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">                Updates the V matrix by iterating over k2 range and performing several operations on it:</span>
<span class="sd">                1. Updates the R matrix by adding the outer product of P[:, idx_j] and V[idx_j, :].</span>
<span class="sd">                2. Calls the '_update_kth_block_v_unit' method for further updates.</span>
<span class="sd">                3. Calls the '_apply_orthog_v_unit' method to apply orthogonal constraint.</span>
<span class="sd">                4. Calls the '_apply_sparsity_v_unit' method to enforce sparsity constraint.</span>
<span class="sd">                5. Calls the '_enforce_non_zero_v' method to ensure non-zero values in V matrix.</span>
<span class="sd">                6. Finally, updates the R matrix by subtracting the outer product of P[:, idx_j] and V[idx_j, :].</span>

<span class="sd">                Returns:</span>
<span class="sd">                    None</span>
<span class="sd">                """</span>
        <span class="k">for</span> <span class="n">idx_j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[:,</span> <span class="n">idx_j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idx_j</span><span class="p">,</span> <span class="p">:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_kth_block_v_unit</span><span class="p">(</span><span class="n">idx_j</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_apply_orthog_v_unit</span><span class="p">(</span><span class="n">idx_j</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_apply_sparsity_v_unit</span><span class="p">(</span><span class="n">idx_j</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_enforce_non_zero_v</span><span class="p">(</span><span class="n">idx_j</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[:,</span> <span class="n">idx_j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idx_j</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_updateS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Updates the matrix R based on the values in matrix S and the matrices U and V.</span>

<span class="sd">        This method performs the following operations:</span>
<span class="sd">        1. Computes the updated value of matrix R by calculating the product of matrices U, S, and V.</span>
<span class="sd">        2. Adjusts the matrix R according to the current state of S, U, and V.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        """</span>

        <span class="k">for</span> <span class="n">idx_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">idx_j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="n">idx_j</span><span class="p">]</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">idx_i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idx_j</span><span class="p">,</span> <span class="p">:])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_ith_jth_of_s</span><span class="p">(</span><span class="n">idx_i</span><span class="p">,</span> <span class="n">idx_j</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="n">idx_j</span><span class="p">]</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span class="n">idx_i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idx_j</span><span class="p">,</span> <span class="p">:])</span>
            <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="p">:])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1e-5</span>

        <span class="k">for</span> <span class="n">idx_j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[:,</span> <span class="n">idx_j</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[:,</span> <span class="n">idx_j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-5</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="NMTF.update">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.update">[docs]</a>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Defines one update step for the U, V, and S factors.</span>

<span class="sd">        This method updates the U, V, and S matrices in one iteration by performing the necessary operations for</span>
<span class="sd">        each matrix, including applying regularization, sparsity constraints, and other updates to ensure the</span>
<span class="sd">        factors are optimized. It also updates the residual matrix (R) as part of the optimization process.</span>

<span class="sd">        Steps:</span>
<span class="sd">            1. Updates the U matrix using the '_update_U' method.</span>
<span class="sd">            2. Updates the P matrix.</span>
<span class="sd">            3. If lU or aU is greater than 0, recalculates the residual matrix R.</span>
<span class="sd">            4. Updates the V matrix using the '_update_V' method.</span>
<span class="sd">            5. Updates the Q matrix.</span>
<span class="sd">            6. Recalculates the residual matrix R if necessary.</span>
<span class="sd">            7. Updates the S matrix.</span>
<span class="sd">            8. Normalizes and scales U and V matrices.</span>
<span class="sd">            9. Re-updates the P and Q matrices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_U</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_P</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_V</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_Q</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_updateS</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_and_scale_u</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_and_scale_v</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_P</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_Q</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="NMTF.update_unit">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.update_unit">[docs]</a>
    <span class="k">def</span> <span class="nf">update_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Defines one update step for U, V, and S, using the unit rules.</span>

<span class="sd">        This method updates the U, V, and S matrices in one iteration using the unit-based update rules. The update</span>
<span class="sd">        steps ensure that regularization, sparsity constraints, and other necessary updates are applied in the manner</span>
<span class="sd">        that follows the unit rule approach.</span>

<span class="sd">        Steps:</span>
<span class="sd">            1. Updates the U matrix using the '_update_U_unit' method.</span>
<span class="sd">            2. Updates the P matrix.</span>
<span class="sd">            3. Updates the V matrix using the '_update_V_unit' method.</span>
<span class="sd">            4. Updates the Q matrix.</span>
<span class="sd">            5. Updates the S matrix.</span>
<span class="sd">            6. Re-updates the P and Q matrices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        """</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_U_unit</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_P</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_V_unit</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_Q</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_updateS</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_P</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_Q</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">None</span></div>


    <span class="k">def</span> <span class="nf">_determine_reg_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">            Determines the registration state based on the given parameters such as var_lambda, max_lU, sigmoid_schedule,</span>
<span class="sd">            mid_epoch_param, shape_param, var_alpha, max_aU, max_aV. Updates the values of lU, lV, aU, aV accordingly.</span>

<span class="sd">            Steps:</span>
<span class="sd">            1. Checks the value of `var_lambda` to determine if the regularization parameters lU and lV should be adjusted</span>
<span class="sd">               using the sigmoid schedule function or if they should be set to the maximum values.</span>

<span class="sd">            2. Checks the value of `var_alpha` to determine if the sparsity parameters aU and aV should be adjusted</span>
<span class="sd">               using the sigmoid schedule function or if they should be set to the maximum values.</span>

<span class="sd">            Uses instance variables: var_lambda, max_lU, sigmoid_schedule, mid_epoch_param, shape_param, var_alpha, max_aU, max_aV.</span>

<span class="sd">            Returns:</span>
<span class="sd">                None</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_lambda</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_lU</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigmoid_schedule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mid_epoch_param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_param</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_lV</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigmoid_schedule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mid_epoch_param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_param</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_lU</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_lV</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_alpha</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_aU</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigmoid_schedule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mid_epoch_param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_param</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_aV</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigmoid_schedule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mid_epoch_param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_param</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_aU</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_aV</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="NMTF.fit">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.fit">[docs]</a>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">                Fits the data using the optimization algorithm.</span>

<span class="sd">                This method executes the necessary steps to fit the model to the data using an optimization algorithm. It begins by</span>
<span class="sd">                initializing factors, normalizing, and scaling them, and then updates the S matrix. The NMTF algorithm is then started</span>
<span class="sd">                and iterated upon. It tracks the objective function setup and updates the model's factors at each iteration.</span>

<span class="sd">                Steps:</span>

<span class="sd">                1. Initializes the factors (U, V, and S).</span>
<span class="sd">                2. Normalizes and scales the U and V factors.</span>
<span class="sd">                3. Updates the S matrix.</span>
<span class="sd">                4. Tracks the objective function setup.</span>
<span class="sd">                5. Begins the NMTF optimization algorithm.</span>
<span class="sd">                6. During each iteration:</span>
<span class="sd">                    - Updates U, V, and S using the specified update method (legacy or unit-based).</span>
<span class="sd">                    - Calculates the objective value.</span>
<span class="sd">                    - Optionally prints detailed information about the iteration, including time, objective value, and reconstruction error.</span>
<span class="sd">                    - Optionally saves intermediate values of U, S, and V.</span>
<span class="sd">                    - Optionally tracks cluster convergence using the Jaccard Index for both U and V assignments.</span>
<span class="sd">                    - Optionally visualizes and saves intermediate graphical representations of the factors.</span>
<span class="sd">                7. Stops when the relative error falls below a specified tolerance (termTol).</span>

<span class="sd">                Returns:</span>
<span class="sd">                    None</span>
<span class="sd">        """</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">curr_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">stop_marker</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"Initializing NMTF factors"</span><span class="p">)</span>
        <span class="c1"># Initialize factors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_factors</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_and_scale_u</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_and_scale_v</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updateS</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_objective_setup</span><span class="p">()</span>

        <span class="n">U_jaccard</span> <span class="o">=</span> <span class="n">MulticlassJaccardIndex</span><span class="p">(</span><span class="n">num_classes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">'weighted'</span><span class="p">)</span>
        <span class="n">V_jaccard</span> <span class="o">=</span> <span class="n">MulticlassJaccardIndex</span><span class="p">(</span><span class="n">num_classes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">'weighted'</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"Beginning NMTF"</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_clust</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_track_clusters_setup</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_intermediate_graph</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visualize_factors</span><span class="p">()</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw_idle</span><span class="p">()</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">renderer</span><span class="o">.</span><span class="n">buffer_rgba</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_determine_reg_state</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">legacy</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_unit</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_objective</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="n">next_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">"Iter: </span><span class="si">{0}</span><span class="se">\t</span><span class="s2">Iter Time: </span><span class="si">{1:.3f}</span><span class="se">\t</span><span class="s2">Total Time: </span><span class="si">{2:.3f}</span><span class="se">\t</span><span class="s2">Objective: </span><span class="si">{3:.3e}</span><span class="se">\t</span><span class="s2">Relative Delta Objective: </span><span class="si">{4:.3e}</span><span class="se">\t</span><span class="s2">Reconstruction Error: </span><span class="si">{5:.3e}</span><span class="s2">"</span><span class="o">.</span>
                    <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">,</span> <span class="n">next_time</span> <span class="o">-</span> <span class="n">curr_time</span><span class="p">,</span> <span class="n">next_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span>
                <span class="n">curr_time</span> <span class="o">=</span> <span class="n">next_time</span>

            <span class="c1"># If we want intermediate values in U S and V</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_intermediate</span><span class="p">:</span>
                <span class="n">out_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">out_path</span><span class="si">}</span><span class="s2">/ITER_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="si">}</span><span class="s2">"</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">print_USV</span><span class="p">(</span><span class="n">out_path</span><span class="p">)</span>

            <span class="c1"># If we want to know about cluster convergence.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_clust</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">U_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">U_predict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span>
                <span class="n">V_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">V_predict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">U_JI</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_jaccard</span><span class="p">(</span><span class="n">U_target</span><span class="p">,</span> <span class="n">U_predict</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">V_JI</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">V_jaccard</span><span class="p">(</span><span class="n">V_target</span><span class="p">,</span> <span class="n">V_predict</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_intermediate_graph</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visualize_factors</span><span class="p">()</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">renderer</span><span class="o">.</span><span class="n">buffer_rgba</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">termTol</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">stop_marker</span> <span class="o">=</span> <span class="n">stop_marker</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">stop_marker</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stop_marker</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="NMTF.print_USV">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.print_USV">[docs]</a>
    <span class="k">def</span> <span class="nf">print_USV</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_pre</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">               Write the lower-dimensional matrices (U, V, and S) to tab-delimited text files.</span>

<span class="sd">               This method saves the U, V, and S matrices to text files with names based on the</span>
<span class="sd">               provided prefix. The matrices are saved in tab-delimited format and will be named</span>
<span class="sd">               `file_pre_U.txt`, `file_pre_V.txt`, and `file_pre_S.txt`.</span>

<span class="sd">               Args:</span>
<span class="sd">                   file_pre (str): Prefix to append to the file names.</span>

<span class="sd">               Returns:</span>
<span class="sd">                   None</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_pre</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'file_pre must be a string'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">file_pre</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">'_'</span><span class="p">:</span>
            <span class="n">file_pre</span> <span class="o">=</span> <span class="n">file_pre</span> <span class="o">+</span> <span class="s1">'_'</span>

        <span class="n">U_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">U_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">U_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">U_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">U_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">U_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_path</span> <span class="o">+</span> <span class="s1">'/'</span> <span class="o">+</span> <span class="n">file_pre</span> <span class="o">+</span> <span class="s2">"U.txt"</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">'</span><span class="se">\t</span><span class="s1">'</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">V_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">V_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">V_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">V_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_path</span> <span class="o">+</span> <span class="s1">'/'</span> <span class="o">+</span> <span class="n">file_pre</span> <span class="o">+</span> <span class="s2">"V.txt"</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">"</span><span class="se">\t</span><span class="s2">"</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">S_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">S_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">S_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">S_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_path</span> <span class="o">+</span> <span class="s1">'/'</span> <span class="o">+</span> <span class="n">file_pre</span> <span class="o">+</span> <span class="s2">"S.txt"</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">"</span><span class="se">\t</span><span class="s2">"</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="NMTF.print_output">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.print_output">[docs]</a>
    <span class="k">def</span> <span class="nf">print_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Write output files related to the factorization and clustering results.</span>

<span class="sd">        This method writes multiple output files, including the lower-dimensional matrices (U, S, V),</span>
<span class="sd">        terms associated with the objective function (e.g., reconstruction error, lambda regularization terms),</span>
<span class="sd">        and the assignment of U and V at every iteration. It also tracks the stepwise convergence of cluster assignments.</span>

<span class="sd">        The output files include:</span>
<span class="sd">            - `reconstruction_error.txt`: The reconstruction error over iterations.</span>
<span class="sd">            - `lU_error.txt`: The lambda regularization error for U.</span>
<span class="sd">            - `lV_error.txt`: The lambda regularization error for V.</span>
<span class="sd">            - `relative_error.txt`: The relative error over iterations.</span>
<span class="sd">            - `U_assign.txt`: The U assignments at each iteration (if `save_clust` is enabled).</span>
<span class="sd">            - `V_assign.txt`: The V assignments at each iteration (if `save_clust` is enabled).</span>
<span class="sd">            - `V_JI.txt`: The Jaccard Index for V assignments (if `save_clust` is enabled).</span>
<span class="sd">            - `U_JI.txt`: The Jaccard Index for U assignments (if `save_clust` is enabled).</span>

<span class="sd">        :param out_path: The path where the output files will be saved.</span>
<span class="sd">        :type out_path: str</span>

<span class="sd">        :return: None</span>
<span class="sd">        """</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">print_USV</span><span class="p">(</span><span class="n">out_path</span><span class="p">)</span>

        <span class="c1"># if self.track_objective:</span>
        <span class="n">reconstruction_error_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_error</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">reconstruction_error_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">reconstruction_error_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">reconstruction_error_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">out_path</span> <span class="o">+</span> <span class="s2">"/reconstruction_error.txt"</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">"</span><span class="se">\t</span><span class="s2">"</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">lU_error_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lU_error</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">lU_error_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">lU_error_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">lU_error_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">out_path</span> <span class="o">+</span> <span class="s1">'/lU_error.txt'</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">'</span><span class="se">\t</span><span class="s1">'</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">lV_error_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lV_error</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">lV_error_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">lV_error_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">lV_error_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">out_path</span> <span class="o">+</span> <span class="s2">"/lV_error.txt"</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">'</span><span class="se">\t</span><span class="s1">'</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_clust</span><span class="p">:</span>
            <span class="n">U_test_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="n">U_test_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">U_test_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
            <span class="n">U_test_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">out_path</span> <span class="o">+</span> <span class="s2">"/U_assign.txt"</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">'</span><span class="se">\t</span><span class="s1">'</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">V_test_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="n">V_test_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">V_test_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
            <span class="n">V_test_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">out_path</span> <span class="o">+</span> <span class="s2">"/V_assign.txt"</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">'</span><span class="se">\t</span><span class="s1">'</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">V_JI_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_JI</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="n">V_JI_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">V_JI_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
            <span class="n">V_JI_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">out_path</span> <span class="o">+</span> <span class="s2">"/V_JI.txt"</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">'</span><span class="se">\t</span><span class="s1">'</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">U_JI_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_JI</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="n">U_JI_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">U_JI_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
            <span class="n">U_JI_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">out_path</span> <span class="o">+</span> <span class="s2">"/U_JI.txt"</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">'</span><span class="se">\t</span><span class="s1">'</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">relative_error_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">relative_error_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">relative_error_out</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">relative_error_out</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">out_path</span> <span class="o">+</span> <span class="s2">"/relative_error.txt"</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">'</span><span class="se">\t</span><span class="s1">'</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_track_objective_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Initialize and track the objective values for the algorithm's error terms across iterations.</span>

<span class="sd">        This method sets up tensors to store the reconstruction error, U regularization error, V regularization error,</span>
<span class="sd">        relative error, and overall error for each iteration of the algorithm. It then calls `calculate_objective`</span>
<span class="sd">        to compute the initial objective values.</span>

<span class="sd">        Attributes:</span>
<span class="sd">            reconstruction_error (torch.Tensor): Stores the reconstruction error at each iteration.</span>
<span class="sd">            lU_error (torch.Tensor): Stores the U regularization error at each iteration.</span>
<span class="sd">            lV_error (torch.Tensor): Stores the V regularization error at each iteration.</span>
<span class="sd">            relative_error (torch.Tensor): Stores the relative error at each iteration.</span>
<span class="sd">            error (torch.Tensor): Stores the overall error at each iteration.</span>

<span class="sd">        :return: None</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lU_error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lV_error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_objective</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_track_clusters_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Initialize the necessary tensors for tracking clusters setup including U_assign, V_assign, U_JI, V_JI.</span>
<span class="sd">        Set the initial values for U_JI and V_JI as infinity.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_JI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_JI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_JI</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">'inf'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_JI</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">'inf'</span><span class="p">)</span>

<div class="viewcode-block" id="NMTF.save_cluster">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.save_cluster">[docs]</a>
    <span class="k">def</span> <span class="nf">save_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Save cluster assignments and errors for each iteration of the algorithm.</span>

<span class="sd">        This method initializes tensors to store the cluster assignments for both U and V matrices</span>
<span class="sd">        at each iteration of the algorithm. It also initializes tensors for the Jaccard Index (JI)</span>
<span class="sd">        for both U and V and tracks the relative error over iterations.</span>

<span class="sd">        Steps:</span>
<span class="sd">        1. Initializes tensors for storing U cluster assignments (`U_assign`) and Jaccard Index (`U_JI`).</span>
<span class="sd">        2. Initializes tensors for storing V cluster assignments (`V_assign`) and Jaccard Index (`V_JI`).</span>
<span class="sd">        3. Initializes tensor to store the relative error over iterations (`relative_error`).</span>


<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">       """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_JI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_JI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>


<div class="viewcode-block" id="NMTF.assign_cluster">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.assign_cluster">[docs]</a>
    <span class="k">def</span> <span class="nf">assign_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Assign clusters based on the lower-dimensional embedding matrices U and V.</span>

<span class="sd">        This method assigns clusters by taking the `argmax` along the appropriate dimensions of the</span>
<span class="sd">        lower-dimensional embedding matrices `U` and `V`. Specifically, it assigns clusters to each</span>
<span class="sd">        data point based on the maximum value in the corresponding row of `U` (for the U assignments)</span>
<span class="sd">        and the maximum value in the corresponding column of `V` (for the V assignments).</span>

<span class="sd">        The cluster assignments are stored in `U_assign` and `V_assign`.</span>

<span class="sd">        :return: None</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_sigmoid_schedule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mid_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mf">10.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Generates a sigmoid scheduling function for the lambda U and lambda V regularization parameters.</span>

<span class="sd">        This function creates a sigmoid schedule for the regularization parameters `LU` and `LV`, where the values</span>
<span class="sd">        of these parameters achieve half of their maximum value at the `mid_iter` (the midpoint iteration). The</span>
<span class="sd">        steepness of the curve is controlled by the `shape` parameter.</span>

<span class="sd">        :param mid_iter: The midpoint iteration where the schedule reaches half of the maximum value.</span>
<span class="sd">        :type mid_iter: int</span>

<span class="sd">        :param shape: The shape parameter that controls the steepness of the sigmoid curve.</span>
<span class="sd">        :type shape: float</span>

<span class="sd">        :return: The value of the sigmoid schedule at the current iteration.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">shape</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="n">mid_iter</span><span class="p">)))</span>

<div class="viewcode-block" id="NMTF.visualize_factors">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.visualize_factors">[docs]</a>
    <span class="k">def</span> <span class="nf">visualize_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'viridis'</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s1">'nearest'</span><span class="p">,</span> <span class="n">max_u</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_v</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_x</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        This function generates a visual representation of the NMTF factors, allowing users to specify</span>
<span class="sd">        the colormap and interpolation method used for image display.</span>

<span class="sd">        :param cmap: The colormap to be used for visualization. Default is 'viridis'.</span>
<span class="sd">        :type cmap: str, optional</span>

<span class="sd">        :param interp: The interpolation method to be used for image display. Default is 'nearest'.</span>
<span class="sd">        :type interp: str, optional</span>

<span class="sd">        :param max_u: The maximum for color scale. Value between [0, 1] where 1 represents the max value in U.</span>
<span class="sd">            Default is 1.</span>
<span class="sd">        :type max_u: float, optional</span>

<span class="sd">        :param max_v: The maximum for color scale. Value between [0, 1] where 1 represents the max value in V.</span>
<span class="sd">            Default is 1.</span>
<span class="sd">        :type max_v: float, optional</span>

<span class="sd">        :param max_x: The maximum for color scale. Value between [0, 1] where 1 represents the max value in X.</span>
<span class="sd">            Default is 1.</span>
<span class="sd">        :type max_x: float, optional</span>

<span class="sd">        :return: U, S, V  matrix heatmaps with X and product.</span>
<span class="sd">        :rtype: matplotlib.figure.Figure</span>

<span class="sd">        """</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">grids</span> <span class="o">=</span> <span class="n">GridSpec</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">wspace</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">width_ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">),</span> <span class="n">height_ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">))</span>

        <span class="n">U_viz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">U_viz</span> <span class="o">=</span> <span class="p">(</span><span class="n">U_viz</span> <span class="o">-</span> <span class="n">U_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">U_viz</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">U_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">U_viz</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">"auto"</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                  <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_u</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="c1"># ax1.set_title("U Matrix")</span>

        <span class="c1"># Visualize S matrix</span>
        <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">t</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">"auto"</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="c1"># ax2.set_title("S Matrix")</span>

        <span class="c1"># Visualize V matrix</span>
        <span class="n">V_viz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">V_viz</span> <span class="o">=</span> <span class="p">(</span><span class="n">V_viz</span> <span class="o">-</span> <span class="n">V_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">V_viz</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">V_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax3</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">V_viz</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">"auto"</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                   <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_v</span><span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="c1"># ax3.set_title("V Matrix")</span>

        <span class="c1"># Visualize X matrix</span>
        <span class="n">X_est_viz</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">X_est_viz</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_est_viz</span> <span class="o">-</span> <span class="n">X_est_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="p">(</span><span class="n">X_est_viz</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">X_est_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax4</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">X_est_viz</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">"auto"</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                   <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_x</span><span class="p">)</span>
        <span class="c1"># ax4.set_title("X Matrix")</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

        <span class="n">X_viz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">X_viz</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_viz</span> <span class="o">-</span> <span class="n">X_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">X_viz</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">X_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax5</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">ax5</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">X_viz</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">"auto"</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                   <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_x</span><span class="p">)</span>
        <span class="n">ax5</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="NMTF.visualize_factors_sorted">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.visualize_factors_sorted">[docs]</a>
    <span class="k">def</span> <span class="nf">visualize_factors_sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'viridis'</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s1">'nearest'</span><span class="p">,</span> <span class="n">max_u</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_v</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_x</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        This function generates a visual representation of the NMTF factors, allowing users to specify</span>
<span class="sd">        the colormap and interpolation method used for image display.</span>

<span class="sd">        :param cmap: Colormap for the visualization. Default is 'viridis'.</span>
<span class="sd">        :type cmap: str, optional</span>

<span class="sd">        :param interp: Interpolation method for image display. Default is 'nearest'.</span>
<span class="sd">        :type interp: str, optional</span>

<span class="sd">        :param max_u: The maximum for color scale. Value between [0, 1] where 1 represents the max value in U. Default is 1.</span>
<span class="sd">        :type max_u: float, optional</span>

<span class="sd">        :param max_v: The maximum for color scale. Value between [0, 1] where 1 represents the max value in V. Default is 1.</span>
<span class="sd">        :type max_v: float, optional</span>

<span class="sd">        :param max_x: The maximum for color scale. Value between [0, 1] where 1 represents the max value in X. Default is 1.</span>
<span class="sd">        :type max_x: float, optional</span>

<span class="sd">        :return: U, S, V  matrix heatmaps with X and product.</span>
<span class="sd">        :rtype: matplotlib.figure.Figure</span>
<span class="sd">        """</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">grids</span> <span class="o">=</span> <span class="n">GridSpec</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">wspace</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">width_ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">),</span> <span class="n">height_ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">))</span>

        <span class="c1"># Generate Sorting for U</span>
        <span class="n">max_U</span><span class="p">,</span> <span class="n">max_U_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sorting_criteria</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">max_U_idx</span><span class="p">,</span> <span class="n">max_U</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sorted_U_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sorting_criteria</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stable</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Generate Sorting for V</span>
        <span class="n">max_V</span><span class="p">,</span> <span class="n">max_V_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sorting_criteria</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">max_V_idx</span><span class="p">,</span> <span class="n">max_V</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sorted_V_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sorting_criteria</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stable</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">U_viz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">sorted_U_indices</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">U_viz</span> <span class="o">=</span> <span class="p">(</span><span class="n">U_viz</span> <span class="o">-</span> <span class="n">U_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">U_viz</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">U_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">U_viz</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">"auto"</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                   <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_u</span><span class="p">)</span> <span class="c1"># set color scale</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="c1"># ax1.set_title("U Matrix")</span>

        <span class="c1"># Visualize S matrix</span>
        <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">t</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">"auto"</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="c1"># ax2.set_title("S Matrix")</span>

        <span class="c1"># Visualize V matrix</span>
        <span class="n">V_viz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[:,</span> <span class="n">sorted_V_indices</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">V_viz</span> <span class="o">=</span> <span class="p">(</span><span class="n">V_viz</span> <span class="o">-</span> <span class="n">V_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="p">(</span><span class="n">V_viz</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">V_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax3</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">V_viz</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">"auto"</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                   <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_v</span><span class="p">)</span> <span class="c1"># set color scale</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="c1"># ax3.set_title("V Matrix")</span>

        <span class="c1"># Visualize X matrix</span>
        <span class="n">X_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span>
        <span class="n">X_est</span> <span class="o">=</span> <span class="n">X_est</span><span class="p">[</span><span class="n">sorted_U_indices</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">X_est</span> <span class="o">=</span> <span class="n">X_est</span><span class="p">[:,</span> <span class="n">sorted_V_indices</span><span class="p">]</span>
        <span class="n">X_est</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_est</span> <span class="o">-</span> <span class="n">X_est</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">X_est</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">X_est</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax4</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">X_est</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">"auto"</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                   <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_x</span><span class="p">)</span> <span class="c1"># set color scale</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

        <span class="c1"># ax4.set_title("X Matrix")</span>
        <span class="n">X_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">X_temp</span> <span class="o">=</span> <span class="n">X_temp</span><span class="p">[</span><span class="n">sorted_U_indices</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">X_temp</span> <span class="o">=</span> <span class="n">X_temp</span><span class="p">[:,</span> <span class="n">sorted_V_indices</span><span class="p">]</span>
        <span class="n">X_temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_temp</span> <span class="o">-</span> <span class="n">X_temp</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">X_temp</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">X_temp</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax5</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">ax5</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">X_temp</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">"auto"</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                   <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_x</span><span class="p">)</span> <span class="c1"># set color scale</span>
        <span class="n">ax5</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="NMTF.write_gif">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.write_gif">[docs]</a>
    <span class="k">def</span> <span class="nf">write_gif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">"NMTF_fit.gif"</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Save frames of NMTF fit to a GIF figure.</span>

<span class="sd">        This method generates and saves a GIF showing the intermediate steps of the NMTF fitting process.</span>
<span class="sd">        It is important that the `draw_interm ediate_graph` parameter is set to `True` during the fit to</span>
<span class="sd">        capture these frames.</span>

<span class="sd">        :param filename: The file name to save the GIF. Default is "NMTF_fit.gif".</span>
<span class="sd">        :type filename: str, optional</span>

<span class="sd">        :param fps: The desired frames per second for the GIF. Default is 5.</span>
<span class="sd">        :type fps: int, optional</span>

<span class="sd">        :return: None</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"filename must be a str"</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fps</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"fps must be a int"</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fps</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"fps must be positive integer"</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_path</span> <span class="o">+</span> <span class="s1">'/'</span> <span class="o">+</span> <span class="n">filename</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">outfile</span> <span class="o">=</span> <span class="s2">"fit.gif"</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"writing gif to </span><span class="si">{0}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outfile</span><span class="p">))</span>
        <span class="n">imageio</span><span class="o">.</span><span class="n">mimsave</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="NMTF.recluster_V">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.recluster_V">[docs]</a>
    <span class="k">def</span> <span class="nf">recluster_V</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linkage_type</span><span class="o">=</span><span class="s2">"average"</span><span class="p">,</span> <span class="n">dist_metric</span><span class="o">=</span><span class="s1">'euclidean'</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Clusters the V matrix using hierarchical clustering, with the specified linkage type and distance metric.</span>
<span class="sd">        Afterward, it reapplies SCOTCH based on the cluster representations to remove overly redundant factors from S.</span>

<span class="sd">        This process involves performing hierarchical clustering on the V matrix to group similar factors and</span>
<span class="sd">        reduce redundancy. SCOTCH is then reapplied to the clustered data to improve the factorization.</span>

<span class="sd">        :param linkage_type: The type of linkage method to use for hierarchical clustering.</span>
<span class="sd">            Must be one of the following: 'single', 'complete', 'average', or 'ward'.</span>
<span class="sd">            Default is 'average'.</span>
<span class="sd">        :type linkage_type: str</span>

<span class="sd">        :param dist_metric: The distance metric used for calculating pairwise distances in clustering.</span>
<span class="sd">            It can be one of the following: 'cosine', 'euclidean', 'city_block', 'chebyshev',</span>
<span class="sd">            or an integer for a p-metric. Default is 'euclidean'.</span>
<span class="sd">        :type dist_metric: str or int</span>

<span class="sd">        :return: None</span>
<span class="sd">        """</span>
        <span class="c1"># Use a pseudo-Q representation to recluster.</span>
        <span class="c1"># This is to make sure we don't have any additive representations in V</span>
        <span class="c1"># Row normalize</span>

        <span class="k">if</span> <span class="n">dist_metric</span> <span class="o">==</span> <span class="s2">"cosine"</span><span class="p">:</span>
            <span class="n">cosine_sim</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">cosine_similarity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">D</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">cosine_sim</span>
        <span class="k">elif</span> <span class="n">dist_metric</span> <span class="o">==</span> <span class="s2">"euclidean"</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dist_metric</span> <span class="o">==</span> <span class="s2">"city_block"</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dist_metric</span> <span class="o">==</span> <span class="s2">"chebyshev"</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">'inf'</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_metric</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">dist_metric</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Dist metric is invalid. Value must be one of cosine, euclidean, city_block, chebyshev, or"</span>
                             <span class="s2">"an integer for a p metric"</span><span class="p">)</span>

        <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="c1"># Cluster V by S representation for each gene</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">sch</span><span class="o">.</span><span class="n">linkage</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">linkage_type</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">sch</span><span class="o">.</span><span class="n">fcluster</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="s1">'maxclust'</span><span class="p">)</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Estimate a new S based on the mean S per cluster</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">):</span>
            <span class="n">cluster_indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">clusters</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">as_tuple</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cluster_indices</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">[:,</span> <span class="n">cluster_indices</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># refit.</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">curr_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_and_scale_v</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updateS</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_objective_setup</span><span class="p">()</span>
        <span class="n">U_jaccard</span> <span class="o">=</span> <span class="n">MulticlassJaccardIndex</span><span class="p">(</span><span class="n">num_classes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">'weighted'</span><span class="p">)</span>
        <span class="n">V_jaccard</span> <span class="o">=</span> <span class="n">MulticlassJaccardIndex</span><span class="p">(</span><span class="n">num_classes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">'weighted'</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_clust</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_track_clusters_setup</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_intermediate_graph</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visualize_factors</span><span class="p">()</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">renderer</span><span class="o">.</span><span class="n">buffer_rgba</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_determine_reg_state</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">legacy</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_unit</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_objective</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="n">next_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">"Iter: </span><span class="si">{0}</span><span class="se">\t</span><span class="s2">Iter Time: </span><span class="si">{1:.3f}</span><span class="se">\t</span><span class="s2">Total Time: </span><span class="si">{2:.3f}</span><span class="se">\t</span><span class="s2">Objective: </span><span class="si">{3:.3e}</span><span class="se">\t</span><span class="s2">Relative Delta Objective: </span><span class="si">{4:.3e}</span><span class="se">\t</span><span class="s2">Reconstruction Error: </span><span class="si">{5:.3e}</span><span class="s2">"</span><span class="o">.</span>
                    <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">,</span> <span class="n">next_time</span> <span class="o">-</span> <span class="n">curr_time</span><span class="p">,</span> <span class="n">next_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span>
                <span class="n">curr_time</span> <span class="o">=</span> <span class="n">next_time</span>

            <span class="c1"># If we want intermediate values in U S and V</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_intermediate</span><span class="p">:</span>
                <span class="n">out_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">out_path</span><span class="si">}</span><span class="s2">/ITER_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="si">}</span><span class="s2">"</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">print_USV</span><span class="p">(</span><span class="n">out_path</span><span class="p">)</span>

            <span class="c1"># If we want to know about cluster convergence.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_clust</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">U_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">U_predict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span>
                <span class="n">V_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">V_predict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">U_JI</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_jaccard</span><span class="p">(</span><span class="n">U_target</span><span class="p">,</span> <span class="n">U_predict</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">V_JI</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">V_jaccard</span><span class="p">(</span><span class="n">V_target</span><span class="p">,</span> <span class="n">V_predict</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_intermediate_graph</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visualize_factors</span><span class="p">()</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">renderer</span><span class="o">.</span><span class="n">buffer_rgba</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">termTol</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_error</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">citer</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span></div>


<div class="viewcode-block" id="NMTF.visualize_clusters">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.visualize_clusters">[docs]</a>
    <span class="k">def</span> <span class="nf">visualize_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'viridis'</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s1">'nearest'</span><span class="p">,</span> <span class="n">max_x</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Visualizes the factors from the NMTF model.</span>

<span class="sd">        This function generates a visualization of the factors resulting from the NMTF model. It supports customizing the</span>
<span class="sd">        color scheme, interpolation method, and the scaling of the visualization.</span>

<span class="sd">        :param factor_name: The name of the factor to visualize (e.g., 'U', 'V').</span>
<span class="sd">        :type factor_name: str</span>

<span class="sd">        :param cmap: The colormap to use for the visualization. Default is 'viridis'.</span>
<span class="sd">        :type cmap: str, optional</span>

<span class="sd">        :param interp: The interpolation method for rendering. Default is 'nearest'.</span>
<span class="sd">        :type interp: str, optional</span>

<span class="sd">        :param max_val: The maximum value for scaling the color map. Default is 1.</span>
<span class="sd">        :type max_val: float, optional</span>

<span class="sd">        :return: The matplotlib figure object representing the factor visualization.</span>
<span class="sd">        :rtype: matplotlib.figure.Figure</span>
<span class="sd">        """</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">grids</span> <span class="o">=</span> <span class="n">GridSpec</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">hspace</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">wspace</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">width_ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">),</span> <span class="n">height_ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">))</span>

        <span class="c1"># Setup safe color palette for U</span>
        <span class="n">n_u_clusters</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">)</span>
        <span class="n">tab_20</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">'tab20'</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_u_clusters</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ValueWarning</span><span class="p">(</span><span class="s1">'Number of U clusters exceeds maximum number of supported by palette (tab20). Repeat '</span>
                               <span class="s1">'colors will be used.'</span><span class="p">)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">tab_20</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">20</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_u_clusters</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">u_cmap</span> <span class="o">=</span> <span class="n">ListedColormap</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>

        <span class="c1"># Visualize U matrix</span>
        <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">norm</span><span class="o">=</span><span class="s1">'linear'</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">"auto"</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">u_cmap</span><span class="p">,</span>
                   <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

        <span class="n">n_v_clusters</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_v_clusters</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ValueWarning</span><span class="p">(</span><span class="s1">'Number of V clusters exceeds maximum of supported by palette (tab20). Repeat '</span>
                               <span class="s2">"colors will be used."</span><span class="p">)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">tab_20</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">20</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_v_clusters</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">v_cmap</span> <span class="o">=</span> <span class="n">ListedColormap</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>

        <span class="c1"># Visualize V matrix</span>
        <span class="n">ax3</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">norm</span><span class="o">=</span><span class="s1">'linear'</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">"auto"</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">v_cmap</span><span class="p">,</span>
                   <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

        <span class="n">ax4</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">X_viz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">X_viz</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_viz</span> <span class="o">-</span> <span class="n">X_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">X_viz</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">X_viz</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">X_viz</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">'linear'</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">"auto"</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                   <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_x</span><span class="p">)</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="NMTF.visualize_clusters_sorted">
<a class="viewcode-back" href="../NMTF.html#NMTF.NMTF.visualize_clusters_sorted">[docs]</a>
    <span class="k">def</span> <span class="nf">visualize_clusters_sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'viridis'</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s1">'nearest'</span><span class="p">,</span> <span class="n">max_x</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">            Visualizes the clusters by ordering elements of the matrix based on their cluster assignments.</span>

<span class="sd">            The function sorts the elements of the matrix by their cluster order and alternates the color of each</span>
<span class="sd">                cluster between grey and black. This approach avoids potential issues with limited color palettes, ensuring</span>
<span class="sd">                better visual distinction between clusters.</span>

<span class="sd">            :param cmap: The colormap to be used for visualization. Defaults to 'viridis'.</span>
<span class="sd">            :type cmap: str, optional</span>
<span class="sd">            :param interp: The interpolation method for rendering the image. Defaults to 'nearest'.</span>
<span class="sd">            :type interp: str, optional</span>
<span class="sd">            :param max_x: The maximum for color scale. Value between [0, 1] where 1 represents the max value in X.  Default is 1.</span>
<span class="sd">            :type max_x: int, optional</span>
<span class="sd">            :return: Sorted clusters heatmap representation.</span>
<span class="sd">            :rtype: matplotlib.figure.Figure</span>
<span class="sd">        """</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">grids</span> <span class="o">=</span> <span class="n">GridSpec</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">hspace</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">wspace</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">width_ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">),</span> <span class="n">height_ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">))</span>

        <span class="c1"># Generate Sorting for U</span>
        <span class="n">max_U</span><span class="p">,</span> <span class="n">max_U_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sorting_criteria</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">max_U_idx</span><span class="p">,</span> <span class="n">max_U</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sorted_U_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sorting_criteria</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stable</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Generate Sorting for V</span>
        <span class="n">max_V</span><span class="p">,</span> <span class="n">max_V_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sorting_criteria</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">max_V_idx</span><span class="p">,</span> <span class="n">max_V</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sorted_V_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sorting_criteria</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stable</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">barcode_U</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">class_value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span><span class="p">)):</span>
            <span class="n">barcode_U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">U_assign</span> <span class="o">==</span> <span class="n">class_value</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">1.0</span>

        <span class="n">barcode_V</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">class_value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span><span class="p">)):</span>
            <span class="n">barcode_V</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">V_assign</span> <span class="o">==</span> <span class="n">class_value</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">1.0</span>

        <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">barcode_U</span><span class="p">[</span><span class="n">sorted_U_indices</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">"auto"</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'gray'</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                   <span class="n">vmax</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

        <span class="c1"># Visualize V matrix</span>
        <span class="n">ax3</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">barcode_V</span><span class="p">[</span><span class="n">sorted_V_indices</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">"auto"</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'gray'</span><span class="p">,</span>
                   <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="c1"># ax3.set_title("V Matrix")</span>

        <span class="n">X_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()[</span><span class="n">sorted_U_indices</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">sorted_V_indices</span><span class="p">]</span>
        <span class="n">X_temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_temp</span> <span class="o">-</span> <span class="n">X_temp</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">X_temp</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">X_temp</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">ax5</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ax5</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">X_temp</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">"auto"</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                   <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_x</span><span class="p">)</span>
        <span class="n">ax5</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>
</div>




</pre></div>

          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright 2025, Spencer Halberg-Spencer, Harmon Bhasin, Sushmita Roy.
              
          </div>
            Created using
            <a href="http://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>